{"meta":{"title":"敛聪存慧","subtitle":null,"description":null,"author":"Cyril Taylor","url":"https://cyriltaylor.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-09-13T15:32:48.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"about/index.html","permalink":"https://cyriltaylor.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-13T15:31:15.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"categories/index.html","permalink":"https://cyriltaylor.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-09-13T15:33:22.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"contact/index.html","permalink":"https://cyriltaylor.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-13T15:32:13.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://cyriltaylor.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"颜色卡","slug":"Tools/颜色卡","date":"2020-08-12T22:46:51.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/4092107268/","link":"","permalink":"https://cyriltaylor.github.io/posts/4092107268/","excerpt":"","text":".color_iterm { width: 10em; height: 10em; border-radius: 1em; text-align: center; /* padding: 2em; */ margin: 1em; display:inline-block; } .inverted { background: inherit; background-clip: text; -webkit-background-clip: text; color: transparent; margin: 0; text-align: center; filter: invert(100%); } .color_iterm::after { content: \"\"; position: absolute; /* top: 10%; */ width: 10em; height: 10em; /* padding: 2em; */ margin: -6em -5em; z-index: -1; background: inherit; filter: blur(3em); } .color_iterm:hover{ transform: scale(1.2); -webkit-transform: scale(1.2); } 精白#FFFFFFrgb(255,255,255) 银白#E9E7EFrgb(233,231,239) 铅白#F0F0F4rgb(240,240,244) 霜色#E9F1F6rgb(233,241,246) 雪白#F0FCFFrgb(240,252,255) 莹白#E3F9FDrgb(227,249,253) 月白#D6ECF0rgb(214,236,240) 象牙白#FFFBF0rgb(255,251,240) 缟#F2ECDErgb(242,236,222) 鱼肚白#FCEFE8rgb(252,239,232) 白粉#FFF2FDrgb(255,242,253) 茶白#F3F9F1rgb(243,249,241) 鸭卵青#E0EEE8rgb(224,238,232) 素#E0F0E9rgb(224,240,233) 青白#C0EBD7rgb(192,235,215) 蟹壳青#BBCDC5rgb(187,205,197) 花白#C2CCD0rgb(194,204,208) 老银#BACAC6rgb(186,202,198) 灰色#808080rgb(128,128,128) 苍色#75878Argb(117,135,138) 水色#88ADA6rgb(136,173,166) 黝#6B6882rgb(107,104,130) 乌色#725E82rgb(114,94,130) 玄青#3D3B4Frgb(61,59,79) 乌黑#392F41rgb(57,47,65) 黎#75664Drgb(117,102,77) 黧#5D513Crgb(93,81,60) 黝黑#665757rgb(102,87,87) 缁色#493131rgb(73,49,49) 煤黑#312520rgb(49,37,32) 漆黑#161823rgb(22,24,35) 黑色#000000rgb(0,0,0) 樱草色#EAFF56rgb(234,255,86) 鹅黄#FFF143rgb(255,241,67) 鸭黄#FAFF72rgb(250,255,114) 杏黄#FFA631rgb(255,166,49) 橙黄#FFA400rgb(255,164,0) 橙色#FA8C35rgb(250,140,53) 杏红#FF8C31rgb(255,140,49) 橘黄#FF8936rgb(255,137,54) 橘红#FF7500rgb(255,117,0) 藤黄#FFB61Ergb(255,182,30) 姜黄#FFC773rgb(255,199,115) 雌黄#FFC64Brgb(255,198,75) 赤金#F2BE45rgb(242,190,69) 缃色#F0C239rgb(240,194,57) 雄黄#E9BB1Drgb(233,187,29) 秋香色#D9B611rgb(217,182,17) 金色#EACD76rgb(234,205,118) 牙色#EEDEB0rgb(238,222,176) 枯黄#D3B17Drgb(211,177,125) 黄栌#E29C45rgb(226,156,69) 乌金#A78E44rgb(167,142,68) 昏黄#C89B40rgb(200,155,64) 棕黄#AE7000rgb(174,112,0) 琥珀#CA6924rgb(202,105,36) 棕色#B25D25rgb(178,93,37) 茶色#B35C44rgb(179,92,68) 棕红#9B4400rgb(155,68,0) 赭#9C5333rgb(156,83,51) 驼色#A88462rgb(168,132,98) 秋色#896C39rgb(137,108,57) 棕绿#827100rgb(130,113,0) 褐色#6E511Ergb(110,81,30) 棕黑#7C4B00rgb(124,75,0) 赭色#955539rgb(149,85,57) 赭石#845A33rgb(132,90,51) 松花色#BCE672rgb(188,230,114) 柳黄#C9DD22rgb(201,221,34) 嫩绿#BDDD22rgb(189,221,34) 柳绿#AFDD22rgb(175,221,34) 葱黄#A3D900rgb(163,217,0) 葱绿#9ED900rgb(158,217,0) 豆绿#9ED048rgb(158,208,72) 豆青#96CE54rgb(150,206,84) 油绿#00BC12rgb(0,188,18) 葱青#0EB83Argb(14,184,58) 青葱#0AA344rgb(10,163,68) 石绿#16A951rgb(22,169,81) 松柏绿#21A675rgb(33,166,117) 松花绿#057748rgb(5,119,72) 绿沈#0C8918rgb(12,137,24) 绿色#00E500rgb(0,229,0) 草绿#40DE5Argb(64,222,90) 青翠#00E079rgb(0,224,121) 青色#00E09Ergb(0,224,158) 翡翠绿#3DE1ADrgb(61,225,173) 碧绿#2ADD9Crgb(42,221,156) 玉色#2EDFA3rgb(46,223,163) 缥#7FECADrgb(127,236,173) 艾绿#A4E2C6rgb(164,226,198) 石绿#7BCFA6rgb(123,207,166) 碧色#1BD1A5rgb(27,209,165) 青碧#48C0A3rgb(72,192,163) 铜绿#549688rgb(84,150,136) 竹青#789262rgb(120,146,98) 墨灰#758A99rgb(117,138,153) 墨色#50616Drgb(80,97,109) 鸦青#424C50rgb(66,76,80) 黯#41555Drgb(65,85,93) 朱砂#FF461Frgb(255,70,31) 火红#FF2D51rgb(255,45,81) 朱磦#F36838rgb(243,104,56) 妃色#ED5736rgb(237,87,54) 洋粉#FF4777rgb(255,71,119) 品红#F00056rgb(240,0,86) 粉红#FFB3A7rgb(255,179,167) 桃红#F47983rgb(244,121,131) 海棠红#DB5A6Brgb(219,90,107) 樱桃色#C93756rgb(201,55,86) 酡颜#F9906Frgb(249,144,111) 银红#F05654rgb(240,86,84) 大红#FF2121rgb(255,33,33) 石榴红#F20C00rgb(242,12,0) 绛紫#8C4356rgb(140,67,86) 绯红#C83C23rgb(200,60,35) 朱红#FF4C00rgb(255,76,0) 丹#FF4E20rgb(255,78,32) 彤#F35336rgb(243,83,54) 酡红#DC3023rgb(220,48,35) 炎#FF3300rgb(255,51,0) 茜色#CB3A56rgb(203,58,86) 绾#A98175rgb(169,129,117) 檀#B36D61rgb(179,109,97) 嫣红#EF7A82rgb(239,122,130) 洋红#FF0097rgb(255,0,151) 枣红#C32136rgb(195,33,54) 殷红#BE0027rgb(190,0,39) 赫赤#C91F37rgb(201,31,55) 银朱#BF242Argb(191,36,42) 赤#C3272Brgb(195,39,43) 胭脂#9D2933rgb(157,41,51) 栗色#60281Ergb(96,40,30) 玄色#622A1Drgb(98,42,29) 蔚蓝#70F3FFrgb(112,243,255) 蓝#44CEF6rgb(68,206,246) 碧蓝#3EEDE7rgb(62,237,231) 石青#1685A9rgb(22,133,169) 靛青#177CB0rgb(23,124,176) 靛蓝#065279rgb(6,82,121) 花青#003472rgb(0,52,114) 宝蓝#4B5CC4rgb(75,92,196) 蓝灰色#A1AFC9rgb(161,175,201) 藏青#2E4E7Ergb(46,78,126) 藏蓝#3B2E7Ergb(59,46,126) 黛#4A4266rgb(74,66,102) 黛绿#426666rgb(66,102,102) 黛蓝#425066rgb(66,80,102) 黛紫#574266rgb(87,66,102) 紫色#8D4BBBrgb(141,75,187) 紫酱#815463rgb(129,84,99) 酱紫#815476rgb(129,84,118) 紫檀#4C221Brgb(76,34,27) 绀青#003371rgb(0,51,113) 紫棠#56004Frgb(86,0,79) 青莲#801DAErgb(128,29,174) 群青#4C8DAErgb(76,141,174) 雪青#B0A4E3rgb(176,164,227) 丁香色#CCA4E3rgb(204,164,227) 藕色#EDD1D8rgb(237,209,216) 藕合色#E4C6D0rgb(228,198,208)","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"[LeetCode #56] 合并区间","slug":"Algorithm/题库/[LeetCode #56] 合并区间","date":"2020-04-16T15:05:44.000Z","updated":"2020-08-27T18:03:00.900Z","comments":true,"path":"posts/3555285202/","link":"","permalink":"https://cyriltaylor.github.io/posts/3555285202/","excerpt":"1. 题目 2. 题解 3. 实现","text":"1. 题目 2. 题解 3. 实现 1. 题目 Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]][[1,3],[2,6],[8,10],[15,18]][[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]][[1,6],[8,10],[15,18]][[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3][1,3][1,3] and [2,6][2,6][2,6] overlaps, merge them into [1,6][1,6][1,6]. Example 2: Input: [[1,4],[4,5]][[1,4],[4,5]][[1,4],[4,5]] Output: [[1,5]][[1,5]][[1,5]] Explanation: Intervals [1,4][1,4][1,4] and [4,5][4,5][4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]][[1,3],[2,6],[8,10],[15,18]][[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]][[1,6],[8,10],[15,18]][[1,6],[8,10],[15,18]] 解释: 区间 [1,3][1,3][1,3] 和 [2,6][2,6][2,6] 重叠, 将它们合并为 [1,6][1,6][1,6]. 示例 2: 输入: [[1,4],[4,5]][[1,4],[4,5]][[1,4],[4,5]] 输出: [[1,5]][[1,5]][[1,5]] 解释: 区间 [1,4][1,4][1,4] 和 [4,5][4,5][4,5] 可被视为重叠区间。 2. 题解 3. 实现","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"十二种常用排序算法（冒泡、插入、归并、快速排序等包含希尔和计数排序）","slug":"Algorithm/十二种常用排序算法","date":"2020-03-31T15:21:54.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3958140669/","link":"","permalink":"https://cyriltaylor.github.io/posts/3958140669/","excerpt":"1. 前言 2. 简介 3. 特性 3.1. 稳定性 3.2. 时间复杂度 3.3. 空间复杂度 3.4. 比较排序、非比较排序 4. 算法 4.1. 冒泡排序 4.2. 选择排序 4.3. 插入排序 4.4. 希尔排序 4.5. 归并排序 4.6. 快速排序 4.7. 堆排序 4.8. 二叉搜索树排序 4.9. 计数排序 4.10. 桶排序 4.11. 基数排序 4.12. TimSort 5. 总结","text":"1. 前言 2. 简介 3. 特性 3.1. 稳定性 3.2. 时间复杂度 3.3. 空间复杂度 3.4. 比较排序、非比较排序 4. 算法 4.1. 冒泡排序 4.2. 选择排序 4.3. 插入排序 4.4. 希尔排序 4.5. 归并排序 4.6. 快速排序 4.7. 堆排序 4.8. 二叉搜索树排序 4.9. 计数排序 4.10. 桶排序 4.11. 基数排序 4.12. TimSort 5. 总结 1. 前言 排序算法在计算机科学入门课程中很普遍，在学习排序算法的时候，涉及到大量的各种核心算法概念，例如大 OOO 表示法，分治法，堆和二叉树之类的数据结构，随机算法，最佳、最差和平均情况分析，时空权衡以及上限和下限，本文就介绍了十二种排序算法供大家学习。 2. 简介 排序算法是用来根据元素对应的比较运算符重新排列给定的数组的算法，输出的数组是一个根据比较符从小到大或者从大到小依次排列的数组。比较运算符是用于确定相应数据结构中元素的新顺序，比如在整数数组里面，对应的比较符号就是大于或者小于号，用户也可以自己定义对应的比较运算符。 比如如果输入是[4,2,3,1][4,2,3,1][4,2,3,1]，按照从小到大输出，结果应该是[1,2,3,4][1,2,3,4][1,2,3,4] 3. 特性 3.1. 稳定性 如果在数组中有两个元素是相等的，在经过某个排序算法之后，原来在前面的的那个元素仍然在另一个元素的前面，那么我们就说这个排序算法是稳定的。 如果在排序之后，原来的两个相等元素中在前面的一个元素被移到了后面，那么这个算法就是不稳定的。 比如排序之前数组为[3(a),2,3(b)][3(a),2,3(b)][3(a),2,3(b)]（其中aaa和bbb分别代表两个不同的333），经过某个排序算法之后是[2,3(a),3(b)][2,3(a),3(b)][2,3(a),3(b)]，那么这个算法就是稳定的；如果变成了[2,3(b),3(a)][2,3(b),3(a)][2,3(b),3(a)]，那么这个算法是不稳定的。 再比如在按照身高排队去食堂打饭的过程中，小明和小刚的身高都是 170，原来小明在小刚前面，但是经过排序之后小明发现小刚到了他前面了，这样小明肯定对这个不稳定的排序有意见。 3.2. 时间复杂度 时间复杂度反映了算法的排序效率，通常用大OOO表示法来表示，通常暗示这个算法需要的最多操作次数的量级，比如O(n)O(n)O(n)表示最多需要进行nnn量级操作。 3.3. 空间复杂度 空间复杂度反映了算法需要消耗的空间，比如O(1)O(1)O(1)表示只需要常数量级的空间，不会随着数组大小的变化而变化。 如果一个排序算法不需要额外的存储空间，可以直接在原来的数组完成排序操作，这个算法可以被称之为原地算法，空间复杂度是O(1)O(1)O(1) 3.4. 比较排序、非比较排序 如果一个算法需要在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个排序算法就是比较排序，大部分排序算法都是比较排序，比如冒泡排序、插入排序、堆排序等等，这种排序算法的平均时间复杂度最快也只能是O(nlogn)O(nlogn)O(nlogn)。 非比较排序比较典型的有计数排序、桶排序和基数排序，这类排序能够脱离比较排序时间复杂度的束缚，达到O(n)O(n)O(n)级别的效率。 4. 算法 首先定义基本的交换数组元素的基本方法，节省后面的代码量。 12345private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 4.1. 冒泡排序 冒泡排序是从左到右依次比较相邻的两个元素，如果前一个元素比较大，就把前一个元素和后一个交换位置，遍历数组之后保证最后一个元素相对于前面的永远是最大的。然后让最后一个保持不变，重新遍历前n−1n-1n−1个元素，保证第n−1n-1n−1个元素在前n−1n-1n−1个元素里面是最大的。依此规律直到第222个元素是前222个元素里面最大的，排序就结束了。 因为这个排序的过程很像冒泡泡，找到最大的元素不停的移动到最后端，所以这个排序算法就叫冒泡排序 用 Java 代码实现 12345678private void bubbleSort(int[] nums) &#123; for (int i = nums.length - 1; i &gt;= 1; i--) &#123; // 冒泡得到n-1个最大值 for (int j = 1; j &lt;= i; j++) &#123; if (nums[j-1]&gt;nums[j]) swap(nums, j, j-1); // 交换得到较大值 &#125; &#125;&#125; 冒泡排序的最大特点就是代码简单，短短的五行代码就能完成整个排序的操作。 时间复杂度比较稳定不管怎样都需要O(n2)O(n^2)O(n2)次比较，所以是O(n2)O(n^2)O(n2)的时间复杂度。 空间复杂度是O(1)O(1)O(1)，所有操作在原来的数组完成就可以了，不需要额外的空间。 算法是稳定的，在冒泡的过程中如果两个元素相等，那么他们的位置是不会交换的。 4.2. 选择排序 选择排序的思路比较简单，先找到前nnn个元素中最大的值，然后和最后一个元素交换，这样保证最后一个元素一定是最大的，然后找到前n−1n-1n−1个元素中的最大值，和第n−1n-1n−1个元素进行交换，然后找到前n−2n-2n−2个元素中最大值，和第n−2n-2n−2个元素交换，依次类推到第222个元素，这样就得到了最后的排序数组。 其实整个过程和冒泡排序差不多，都是要找到最大的元素放到最后，不同点是冒泡排序是不停的交换元素，而选择排序只需要在每一轮交换一次。 实现代码 1234567891011private void selectionSort(int[] nums) &#123; for (int i = nums.length - 1; i &gt; 0; i--) &#123; int maxIndex = 0; // 最大元素的位置 for (int j = 0; j &lt;= i; j++) &#123; if (nums[maxIndex]&lt;nums[j]) &#123; maxIndex = j; &#125; &#125; swap(nums, maxIndex, i); // 把这个最大的元素移到最后 &#125;&#125; 时间复杂度和冒泡排序一样比较稳定，都需要O(n2)O(n^2)O(n2)次比较，所以时间复杂度是O(n2)O(n^2)O(n2) 空间复杂度是O(1)O(1)O(1)，不需要额外空间，是原地算法。 选择排序最简单的版本是不稳定的，比如数组[1,3,2,2][1,3,2,2][1,3,2,2]，表示为[1,3,2(a),2(b)][1,3,2(a),2(b)][1,3,2(a),2(b)]，在经过一轮遍历之后变成了[1,2(b),2(a),3][1,2(b),2(a),3][1,2(b),2(a),3]，两个222之间的顺序因为第一个222和333的调换而颠倒了，所以不是稳定排序。 不过可以改进一下选择排序变成稳定的。原来不稳定是因为交换位置导致的，现在如果改成插入操作（不是使用数组而是链表，把最大的元素插入到最后）的话，就能变成稳定排序。比如[1,3,2(a),2(b)][1,3,2(a),2(b)][1,3,2(a),2(b)]，在第一轮中变成了[1,2(a),2(b),3][1,2(a),2(b),3][1,2(a),2(b),3]，这样就能够保持相对位置，变成稳定排序。 4.3. 插入排序 插入排序的核心思想是遍历整个数组，保持当前元素左侧始终是排序后的数组，然后将当前元素插入到前面排序完成的数组的对应的位置，使其保持排序状态。有点动态规划的感觉，类似于先把前 i-1 个元素排序完成，再插入第 i 个元素，构成 i 个元素的有序数组。 代码实现 123456789private void insertionSort(int[] nums) &#123; for (int i = 1; i &lt; nums.length; i++) &#123; // 从第二个元素开始遍历 int j = i; while (j&gt;0&amp;&amp;nums[j]&lt;nums[j-1]) &#123; // 将当前元素移动到合适的位置 swap(nums, j, j-1); j--; &#125; &#125;&#125; 时间复杂度上，插入排序在最好的情况，也就是数组已经排好序的时候，复杂度是O(n)O(n)O(n)，在其他情况下都是O(n2)O(n^2)O(n2)。 空间复杂度是O(1)O(1)O(1)，不需要额外的空间，是原地算法。 插入排序是稳定排序，每次交换都是相邻元素的交换，不会有选择排序的那种跳跃式交换元素。 4.4. 希尔排序 希尔排序可以看作是一个冒泡排序或者插入排序的变形。希尔排序在每次的排序的时候都把数组拆分成若干个序列，一个序列的相邻的元素索引相隔的固定的距离gapgapgap，每一轮对这些序列进行冒泡或者插入排序，然后再缩小gapgapgap得到新的序列一一排序，直到gapgapgap为 0 比如对于数组[5,2,4,3,1,2][5,2,4,3,1,2][5,2,4,3,1,2]，第一轮 gap=3 拆分成[5,3][5,3][5,3]、[2,1][2,1][2,1]和[4,2][4,2][4,2]三个数组进行插入排序得到[3,1,2,5,2,4][3,1,2,5,2,4][3,1,2,5,2,4]；第二轮gap=1gap=1gap=1，拆分成[3,2,2][3,2,2][3,2,2]和[1,5,4][1,5,4][1,5,4]进行插入排序得到[2,1,2,4,3,5][2,1,2,4,3,5][2,1,2,4,3,5]；最后gap=0gap=0gap=0，全局插入排序得到[1,2,2,3,4,5][1,2,2,3,4,5][1,2,2,3,4,5] 代码实现 123456789101112131415private void shellSor2(int[] nums) &#123; int gap = nums.length &gt;&gt; 1; while (gap &gt; 0) &#123; for (int i = 0; i &lt; gap; i++) &#123; // 对每个子序列进行排序 for (int j = i+gap; j &lt; nums.length; j+=gap) &#123; // 插入排序的部分 int temp = j; while (temp &gt; i &amp;&amp; nums[temp] &lt; nums[temp-gap]) &#123; swap(nums, temp, temp-gap); temp -= gap; &#125; &#125; &#125; gap &gt;&gt;= 1; &#125;&#125; Donald Shell 于 1959 年发布了这种排序算法，运行时间在很大程度上取决于它使用的间隔，在实际使用中，其时间复杂度仍然是一个悬而未决的问题，基本在O(n2)O(n^2)O(n2)和O(n43)O(n^\\frac{4}{3})O(n34​)之间。 空间复杂度是O(1)O(1)O(1)，是原地算法。 这个算法是不稳定的，里面有很多不相邻元素的交换操作。 4.5. 归并排序 归并排序是典型的使用分治思想（divide-and-conquer）解决问题的案例。在排序的过程中，把原来的数组变成左右两个数组，然后分别进行排序，当左右的子数组排序完毕之后，再合并这两个子数组形成一个新的排序数组。整个过程递归进行，当只剩下一个元素或者没有元素的时候就直接返回。 代码实现 12345678910111213141516171819202122private void mergeSort(int[] nums, int left, int right) &#123; // 需要左右边界确定排序范围 if (left &gt;= right) return; int mid = (left+right) / 2; mergeSort(nums, left, mid); // 先对左右子数组进行排序 mergeSort(nums, mid+1, right); int[] temp = new int[right-left+1]; // 临时数组存放合并结果 int i=left,j=mid+1; int cur = 0; while (i&lt;=mid&amp;&amp;j&lt;=right) &#123; // 开始合并数组 if (nums[i]&lt;=nums[j]) temp[cur] = nums[i++]; else temp[cur] = nums[j++]; cur++; &#125; while (i&lt;=mid) temp[cur++] = nums[i++]; while (j&lt;=right) temp[cur++] = nums[j++]; for (int k = 0; k &lt; temp.length; k++) &#123; // 合并数组完成，拷贝到原来的数组中 nums[left+k] = temp[k]; &#125;&#125; 时间复杂度上归并排序能够稳定在O(nlogn)O(nlogn)O(nlogn)的水平，在每一级的合并排序数组过程中总的操作次数是 n，总的层级数是lognlognlogn，相乘得到最后的结果就是O(nlogn)O(nlogn)O(nlogn) 空间复杂度是O(n)O(n)O(n)，因为在合并的过程中需要使用临时数组来存放临时排序结果。 归并排序是稳定排序，保证原来相同的元素能够保持相对的位置。 4.6. 快速排序 快速排序（有时称为分区交换排序）是一种高效的排序算法。由英国计算机科学家 Tony Hoare 于 1959 年开发并于 1961 年发表，它在现在仍然是一种常用的排序算法。如果实现方法恰当，它可以比主要竞争对手（归并排序和堆排序）快两到三倍。 其核心的思路是取第一个元素（或者最后一个元素）作为分界点，把整个数组分成左右两侧，左边的元素小于或者等于分界点元素，而右边的元素大于分界点元素，然后把分界点移到中间位置，对左右子数组分别进行递归，最后就能得到一个排序完成的数组。当子数组只有一个或者没有元素的时候就结束这个递归过程。 其中最重要的是将整个数组根据分界点元素划分成左右两侧的逻辑，目前有两种算法，图片展示的是第一种。 第一种实现，也是图片中的排序逻辑的实现： 1234567891011121314151617private void quickSort(int[] nums, int left, int right) &#123; if (left &gt;= right) return; int lo = left+1; // 小于分界点元素的最右侧的指针 int hi = right; // 大于分界点元素的最左侧的指针 while (lo&lt;=hi) &#123; if (nums[lo]&gt;nums[left]) &#123; // 交换元素确保左侧指针指向元素小于分界点元素 swap(nums, lo, hi); hi--; &#125; else &#123; lo++; &#125; &#125; lo--; // 回到小于分界点元素数组的最右侧 swap(nums, left, lo); // 将分界点元素移到左侧数组最右侧 quickSort2(nums, left, lo-1); quickSort2(nums, lo+1, right);&#125; 第二种，不用hi来标记大于分界点元素的最右侧，而是只用一个lo来标记最左侧。在遍历整个数组的过程中，如果发现了一个小于等于分界点元素的元素，就和lo+1位置的元素交换，然后lo自增，这样可以保证lo的左侧一定都是小于等于分界点元素的，遍历到最后lo的位置就是新的分界点位置，和最开始的分界点元素位置互换。 123456789101112131415private void quickSort(int[] nums, int left, int right) &#123; if (left&gt;=right) return; int cur = left + 1; // 从左侧第二个元素开始 int lo = left; // 分界点为第一个元素 while (cur &lt;= right) &#123; if (nums[cur] &lt;= nums[left]) &#123; // 交换位置保证lo的左侧都是小于num[left] swap(nums, lo+1, cur); lo ++; &#125; cur++; &#125; swap(nums, left, lo); // 把分界点元素移动到新的分界位置 quickSort(nums, left, lo-1); quickSort(nums, lo+1, right);&#125; 时间复杂度在最佳情况是O(nlogn)O(nlogn)O(nlogn)，但是如果分界点元素选择不当可能会恶化到O(n2)O(n2^)O(n2)，但是这种情况比较少见（比如数组完全逆序），如果随机选择分界点的话，时间复杂度能够稳定在O(nlogn)O(nlogn)O(nlogn)。另外如果元素中相同元素数量比较多的话，也会降低排序性能。 空间复杂度在O(logn)O(logn)O(logn)水平，属于堆栈调用，在最坏的情况下空间复杂度还是O(n)O(n)O(n)，平均情况下复杂度是O(logn)O(logn)O(logn) 快速排序是不稳定的，因为包含跳跃式交换元素位置。 4.7. 堆排序 堆排序是一个效率要高得多的选择排序，首先把整个数组变成一个最大堆，然后每次从堆顶取出最大的元素，这样依次取出的最大元素就形成了一个排序的数组。堆排序的核心分成两个部分，第一个是新建一个堆，第二个是弹出堆顶元素后重建堆。 新建堆不需要额外的空间，而是使用原来的数组，一个数组在另一个维度上可以当作一个完全二叉树（除了最后一层之外其他的每一层都被完全填充，并且所有的节点都向左对齐），对于下标为iii的元素，他的子节点是2∗i+12*i+12∗i+1和2∗i+22*i+22∗i+2（前提是没有超出边界）。在新建堆的时候从左向右开始遍历，当遍历到一个元素的时候，重新排列从这个元素节点到根节点的所有元素，保证满足最大堆的要求（父节点比子节点要大）。遍历完整个数组的时候，这个最大堆就完成了。 在弹出根节点之后（把根节点的元素和树的最底层最右侧的元素互换），堆被破坏，需要重建。从根节点开始和两个子节点比较，如果父节点比最大的子节点小，那么就互换父节点和最大的子节点，然后把互换后在子节点位置的父节点当作新的父节点，和它的子节点比较，如此往复直到最后一层，这样最大堆就重建完毕了。 代码实现： 12345678910111213141516171819202122232425262728293031323334private void heapSort(int[] nums) &#123; heapify(nums); // 新建一个最大堆 for (int i = nums.length - 1; i &gt;= 1; i--) &#123; swap(nums, 0, i); // 弹出最大堆的堆顶放在最后 rebuildHeap(nums, 0,i-1); // 重建最大堆 &#125;&#125;private void heapify(int[] nums) &#123; for (int i = 1; i &lt; nums.length; i++) &#123; int par = (i-1)&gt;&gt;1; // 找到父节点 int child = i; // 定义子节点 while (child&gt;0&amp;&amp;nums[par]&lt;nums[child]) &#123; // 从子节点到根节点构建最大堆 swap(nums, par, child); child = par; par = (par-1) &gt;&gt; 1; &#125; &#125;&#125;private void rebuildHeap(int[] nums, int par, int last) &#123; int left = 2*par+1; // 左子节点 int right = 2*par+2; // 右子节点 int maxIndex = left; if (right&lt;=last &amp;&amp; nums[right]&gt;nums[left]) &#123; // 找到最大子节点 maxIndex = right; &#125; if (left&lt;=last &amp;&amp; nums[par] &lt; nums[maxIndex]) &#123;// 和最大子节点比较 swap(nums, par, maxIndex); // 互换到最大子节点 rebuildHeap(nums, maxIndex, last); // 重建最大子节点代表的子树 &#125;&#125; 时间复杂度稳定在O(nlogn)O(nlogn)O(nlogn)，因为在构建堆的时候时间遍历数组对于每个元素需要进行O(logn)O(logn)O(logn)次比较，时间复杂度是O(nlogn)O(nlogn)O(nlogn)。在弹出每个元素重建堆需要O(logn)O(logn)O(logn)的复杂度，时间复杂度也是O(nlogn)O(nlogn)O(nlogn)，所以整体的时间复杂度是O(nlogn)O(nlogn)O(nlogn) 空间复杂度是O(1)O(1)O(1)，在原数组进行所有操作就可以了。 堆排序是不稳定，堆得构建和重建的过程都会打乱元素的相对位置。 堆排序的代码量相对于其他的排序算法来说是比较多的，理解上也比较难，涉及到最大堆和二叉树等相关概念。虽然在实际使用中相对于快速排序不是那么好用，但是最坏情况下的O(nlogn)O(nlogn)O(nlogn)的时间复杂度也是优于快排的。空间使用是恒定的，是优于归并排序。 4.8. 二叉搜索树排序 二叉树搜索排序用数组内的所有元素构建一个搜索二叉树，然后用中序遍历重新将所有的元素填充回原来的数组中。因为搜索二叉树不能用数组来表示，所以必须使用额外的数据结构来构建二叉树。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142private int[] bstSort(int[] nums) &#123; TreeNode root = new TreeNode(nums[0]); // 构建根节点 for (int i = 1; i &lt; nums.length; i++) &#123; // 将所有的元素插入到二叉搜索树中 buildTree(root, nums[i]); &#125; inorderTraversal(root, nums, new int[1]);// 中序遍历获取二叉树中的所有节点 return nums;&#125;private void inorderTraversal(TreeNode node, int[] nums, int[] pos) &#123; if (node == null) return; inorderTraversal(node.left, nums, pos); nums[pos[0]++] = node.val; inorderTraversal(node.right, nums, pos);&#125;private void buildTree(TreeNode node, int num) &#123; if (node == null) return; if (num &gt;= node.val) &#123; // 插入到右子树中 if (node.right == null) &#123; node.right = new TreeNode(num); &#125; else &#123; buildTree(node.right, num); &#125; &#125; else &#123; // 插入到左子树中 if (node.left == null) &#123; node.left = new TreeNode(num); &#125; else &#123; buildTree(node.left, num); &#125; &#125;&#125;static class TreeNode &#123; // 树节点的数据结构 int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 时间复杂度上面根据原数组变化比较大，最差情况是整个数组是已经排好序的，这样二叉树会变成一个链表结构，时间复杂度退化到了O(n2)O(n^2)O(n2)，但是最优和平均情况下时间复杂度在O(nlogn)O(nlogn)O(nlogn)水平。 空间复杂度是O(n)O(n)O(n)，因为要构建一个包含nnn个元素的二叉搜索树。 这个算法是稳定，在构建二叉树的过程中能够保证元素顺序的一致性。 4.9. 计数排序 计数排序是一个最基本的非比较排序，能够将时间复杂度提高到O(n)O(n)O(n)的水平，但是使用上比较有局限性，通常只能应用在键的变化范围比较小的情况下，如果键的变化范围特别大，建议使用基数排序。 计数排序的过程是创建一个长度为数组中最小和最大元素之差的数组，分别对应数组中的每个元素，然后用这个新的数组来统计每个元素出现的频率，然后遍历新的数组，根据每个元素出现的频率把元素放回到老的数组中，得到已经排好序的数组。 代码实现： 12345678910111213141516171819private void countSort(int[] nums) &#123; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int num : nums) &#123; // 找到最大最小值 min = Math.min(min, num); max = Math.max(max, num); &#125; int[] count = new int[max-min+1]; // 建立新数组 for (int num : nums) &#123; // 统计每个元素出现频率 count[num-min]++; &#125; int cur = 0; for (int i = 0; i &lt; count.length; i++) &#123; // 根据出现频率把计数数组中的元素放回到旧数组中 while (count[i]&gt;0) &#123; nums[cur++] = i+min; count[i]--; &#125; &#125;&#125; 计数排序能够将时间复杂度降低到O(n+r)O(n+r)O(n+r)（rrr为数组元素变化范围），不过这是对于数组元素的变化范围不是特别大。随着范围的变大，计数排序的性能就会逐渐降低。 空间复杂度为O(n+r)O(n+r)O(n+r)，随着数组元素变化范围的增大，空间复杂度也会变大。 计数排序是稳定的，原来排在前面的相同在计数的时候，仍然是排在每个计数位置的前面，在最后复原的时候也是从每个计数位的前面开始复原，所以最后相对位置还是相同的。 4.10. 桶排序 桶排序是将所有的元素分布到一系列的区间（也可以称之为桶）里面，然后对每个桶里面的所有元素分别进行排序的算法。 首先新建一个桶的数组，每个桶的规则需要提前制定好，比如元素在 0~9 为一个桶、10~19 为一个桶。然后遍历整个待排序的数组，把元素分配到对应的桶里面。接下来单独对每个桶里面的元素进行排序，排序算法可以选择比较排序或者非比较排序，得到排序后的数组。最后把所有的桶内的元素还原到原数组里面得到最后的排序数组。 代码实现： 1234567891011121314151617181920212223242526private void bucketSort(int[] nums) &#123; int INTERVAL = 100; // 定义桶的大小 int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int num : nums) &#123; // 找到数组元素的范围 min = Math.min(min, num); max = Math.max(max, num); &#125; int count = (max - min + 1); // 计算出桶的数量 int bucketSize = (count % INTERVAL == 0) ?( count / INTERVAL) : (count / INTERVAL+1); List&lt;Integer&gt;[] buckets = new List[bucketSize]; for (int num : nums) &#123; // 把所有元素放入对应的桶里面 int quotient = (num-min) / INTERVAL; if (buckets[quotient] == null) buckets[quotient] = new ArrayList&lt;&gt;(); buckets[quotient].add(num); &#125; int cur = 0; for (List&lt;Integer&gt; bucket : buckets) &#123; if (bucket != null) &#123; bucket.sort(null); // 对每个桶进行排序 for (Integer integer : bucket) &#123; // 还原桶里面的元素到原数组 nums[cur++] = integer; &#125; &#125; &#125;&#125; 时间复杂度上桶排序和计数排序一样，是O(n+r)O(n+r)O(n+r)的水平，但是随着数据元素范围的增大，时间消耗也在增大。 空间复杂度也是O(n+r)O(n+r)O(n+r)，需要额外的空间来保存所有的桶和桶里面的元素。 桶排序是稳定的（前提是桶内排序的逻辑是稳定的），和计数排序的逻辑类似，遍历过程插入桶的过程中没有改变相同元素的相对位置，排序也没有改变，最后的还原也没有改变。 4.11. 基数排序 基数排序和桶排序有点相似，基数排序中需要把元素送入对应的桶中，不过规则是根据所有数字的某一位上面的数字来分类。 假设当前数组的所有元素都是正数，桶的数量就固定在了 10 个，然后计算出最大元素的位数。首先根据每个元素的最低位进行分组，比如1就放入1这个桶，13就放入3这个桶，111也放入1这个桶，然后把所有的数字根据桶的顺序取出来，依次还原到原数组里面。在第二轮从第二位开始分组，比如1（看作01）放入0这个桶，13放入1这个桶，111也放入1这个桶，再把所有的元素从桶里面依次取出放入原数组。经过最大元素位数次的这样的操作之后，还原得到的数组就是一个已经排好序的数组。 考虑到数组里面还有负数的情况，可以把桶的大小扩大到 19 个，分别代表对应位在-9~9 之间的数字，代码如下： 1234567891011121314151617181920212223242526272829303132333435private void radixSort(int[] nums) &#123; int max = -1; int min = 1; for (int num : nums) &#123; // 计算最大最小值 max = Math.max(max, num); min = Math.min(min, num); &#125; max = Math.max(max, -min); // 求得绝对值最大的值 int digits = 0; while (max &gt; 0) &#123; // 计算绝对值最大的值的位数 max /= 10; digits++; &#125; List&lt;Integer&gt;[] buckets = new List[19]; // 建一个包含所有位数的数组 for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new ArrayList&lt;&gt;(); &#125; int pos; int cur; for (int i = 0, mod = 1; i &lt; digits; i++, mod*=10) &#123; // 对十进制每一位进行基数排序 for (int num : nums) &#123; // 扫描数组将值放入对应的桶 pos = (num / mod) % 10; buckets[pos+9].add(num); &#125; cur = 0; for (List&lt;Integer&gt; bucket : buckets) &#123; // 将桶内元素放回到数组里面 if (bucket!=null) &#123; for (Integer integer : bucket) &#123; nums[cur++] = integer; &#125; bucket.clear(); // 将桶清空 &#125; &#125; &#125;&#125; 时间复杂度基本在O(n⋅kd)O(n·\\frac{k}{d})O(n⋅dk​)水平，其中kkk为 key 的总数量，ddd为绝对值最大的数字的十进制位数。 空间复杂度是O(n+2d)O(n+2^d)O(n+2d)。 基数排序是一个稳定排序算法，在排序添加元素的过程中没有改变相同元素的相互位置。 4.12. TimSort Timsort 是由 Tim Peters 在 2002 年实现的，自 Python 2.3 以来，它一直是 Python 的标准排序算法。Java 在 JDK 中使用 Timsort 对非基本类型进行排序。Android 平台和 GNU Octave 还将其用作默认排序算法。 Timsort 是一种稳定的混合排序算法，同时应用了二分插入排序和归并排序的思想，在时间上击败了其他所有排序算法。它在最坏情况下的时间复杂度为O(nlogn)O(nlogn)O(nlogn)优于快速排序；最佳情况的时间复杂度为O(n)O(n)O(n)，优于归并排序和堆排序。 由于使用了归并排序，使用额外的空间保存数据，TimSort 空间复杂度是O(n)O(n)O(n) 由于篇幅原因，TimSort 的具体实现过程暂且就不讲了，会有一篇专门的文章来介绍 TimSort。 5. 总结 排序算法 最好情况 平均情况 最差情况 空间复杂度 稳定性 冒泡排序 n2n^2n2 n2n^2n2 n2n^2n2 111 ✓ 选择排序 n2n^2n2 n2n^2n2 n2n^2n2 111 插入排序 nnn n2n^2n2 n2n^2n2 111 ✓ 希尔排序 nlognnlognnlogn n43n^\\frac{4}{3}n34​ n43n^\\frac{4}{3}n34​ 111 二叉树排序 nlognnlognnlogn nlognnlognnlogn n2n^2n2 nnn ✓ 归并排序 nlognnlognnlogn nlognnlognnlogn nlognnlognnlogn nnn ✓ 快速排序 nlognnlognnlogn nlognnlognnlogn n2n^2n2 lognlognlogn 堆排序 nlognnlognnlogn nlognnlognnlogn nlognnlognnlogn 111 计数排序 - n+rn+rn+r n+rn+rn+r n+rn+rn+r ✓ 桶排序 - n+rn+rn+r n+rn+rn+r n+rn+rn+r ✓ 基数排序 - nkdn\\frac{k}{d}ndk​ nkdn\\frac{k}{d}ndk​ n+2dn+2^dn+2d ✓ TimSort nnn nlognnlognnlogn nlognnlognnlogn nnn ✓ 备注：rrr为排序数字的范围，ddd是数字总位数，kkk是数字总个数 上面的表格总结了讲到的排序算法的时间和空间复杂度以及稳定性等，在实际应用中会有各种排序算法变形的问题，都可以通过优化排序算法来达到优化算法的目的。 如果对时间复杂度要求比较高并且键的分布范围比较广，可以使用归并排序、快速排序和堆排序。 如果不能使用额外的空间，那么快速排序和堆排序都是不错的选择。 如果规定了排序的键的范围，可以优先考虑使用桶排序。 如果不想写太多的代码同时时间复杂度没有太高的要求，可以考虑冒泡排序、选择排序和插入排序。 如果排序的过程中没有复杂的额外操作，直接使用编程语言内置的排序算法就行了。 参考 超详细十大经典排序算法总结（java 代码） 十大经典排序算法 十大经典排序算法（动图演示） Sorting algorithm Timsort Data Structure - Sorting Techniques This is the fastest sorting algorithm ever Timsort: The Fastest sorting algorithm for real-world problems","categories":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://cyriltaylor.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":[{"name":"佛西先森","homepage":"http://sunshuyi.vip","photo":"avatar.jpg"}]},{"title":"水果搬运","slug":"Algorithm/题库/水果搬运","date":"2020-03-18T15:26:02.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/2107682388/","link":"","permalink":"https://cyriltaylor.github.io/posts/2107682388/","excerpt":"1. 问题描述 2. 示例 3. 分析与实现 代码实现","text":"1. 问题描述 2. 示例 3. 分析与实现 代码实现 1. 问题描述 输入N(0&lt;N&lt;100&gt;)行，每行包含一个水果名称，搬运工的编号，以及搬运工搬运的重量，现在要求按照如下规则对输入的数据进行排序； a. 优先按照水果的输入顺序进行排序，同一类水果作为一组排在一起； b. 同类水果按照搬运的重量从小到大排序； c. 同类水果同样重量，按照搬运工编号从小到大排序 2. 示例 输入： 123456789109Apple 1 65Apple 3 95Orange 4 76Apple 4 87Apple 6 92Orange 5 95Orange 3 77Apple 2 68Orange 6 92 输出： 123456789Apple 1 65Apple 2 68Apple 4 87Apple 6 92Apple 3 95Orange 4 76Orange 3 77Orange 6 92Orange 5 95 3. 分析与实现 代码实现 C++版本： 12345class Solution &#123; protected vector&lt;vector&lt;int&gt;&gt; sortFruitPorter(vector&lt;vector&lt;int&gt;&gt; &amp;listFruitPorter) &#123; return NULL; &#125;&#125; java版本： 1 Python版本： 1","categories":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题库","slug":"题库","permalink":"https://cyriltaylor.github.io/tags/%E9%A2%98%E5%BA%93/"},{"name":"华为机试","slug":"华为机试","permalink":"https://cyriltaylor.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"算法常用技巧","slug":"Algorithm/算法常用技巧","date":"2020-03-14T08:37:57.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/2649952161/","link":"","permalink":"https://cyriltaylor.github.io/posts/2649952161/","excerpt":"1. 算法常用函数 1.1. C++ 2. 算法常见解法 2.1. 相除法求最大公约数 2.2. 求立方根 2.3. 小数取整","text":"1. 算法常用函数 1.1. C++ 2. 算法常见解法 2.1. 相除法求最大公约数 2.2. 求立方根 2.3. 小数取整 1. 算法常用函数 1.1. C++ 2. 算法常见解法 2.1. 相除法求最大公约数 2.2. 求立方根 2.3. 小数取整","categories":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"技巧","slug":"技巧","permalink":"https://cyriltaylor.github.io/tags/%E6%8A%80%E5%B7%A7/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"软件推荐","slug":"Tools/软件推荐","date":"2020-02-17T15:33:04.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3374613233/","link":"","permalink":"https://cyriltaylor.github.io/posts/3374613233/","excerpt":"1. PowerPoint插件 1.1. iSlide 1.2. OneKey 1.3. LvyhTools","text":"1. PowerPoint插件 1.1. iSlide 1.2. OneKey 1.3. LvyhTools 1. PowerPoint插件 1.1. iSlide iSlide是一款基于PowerPoint的插件工具，包含38个设计辅助功能，8大在线资源库超20万专业PPT模板/素材。 功能特性： 一键优化 将PPT中不规则的字体，段落，色彩，参考线布局，风格样式等一键化全局统一设置，构建专业和规范。 设计排版 高效智能化实现PPT页面设计中的图形布局和复制排列工作，多种参数化设置满足个性化设计需求。 主题库 主题包含专属的字体，色彩，效果规则，封面，封底，版式，可帮助你快速简便建立专业PPT文档。 色彩库 更多专业的色彩组合搭配方案，可按色系检索选择，一键化替换，实现全文档色彩的统一应用。 图示库 4000+专业开发的功能图示化模板素材，全矢量设计，自适PPT主题配色和版式规则，编辑方便。 智能图表 在PPT中创建更具视觉吸引力的个性化图表，智能化数据参数调整，图表编辑实时预览。 图片库 可在任何地方使用的Creative Commons CC0协议下的真正免费图片，快速检索，一键插入PPT。 图标库 拥有100，000+扁平化图标素材资源，任意下载，一键插入PPT，可随时根据需求修改替换。 安全导出 将重要类型PPT文档导出为不可编辑格式，以及各种参数化设置的视频与图片。 PPT拼图 将PPT页面按需排列组合，一键导出为长图，参数化调节可自由控制输出图片质量和尺寸大小。 PPT瘦身 一键优化清理PPT中的冗余信息，对PPT中包含的图片进行智能压缩，减小文档体积。 P圈 汇集PPT界的各类讯息，达人，资源和教程，快速提升PPT设计的最佳捷径。 1.2. OneKey OneKey 1.3. LvyhTools LvyhTools插件包含PPT转Word、字体收藏、字体导出、顶点编辑、线条编辑、形状编辑、位置分布等功能。能帮我们快速地将复杂操作变简单。","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"PowerShell详解","slug":"Shell/PowerShell详解","date":"2020-01-17T02:30:16.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/4053355734/","link":"","permalink":"https://cyriltaylor.github.io/posts/4053355734/","excerpt":"1. 认识Powershell 1.1. 介绍和安装 1.2. 自定义控制台 1.3. 快速编辑模式和标准模式 1.4. 快捷键 1.5. 管道和重定向 2. Powershell交互式 2.1. 数学运算 2.2. 执行外部命令 2.3. 命令集 2.4. 别名 2.5. 通过函数扩展别名 2.6. 执行文件和脚本 3. Powershell变量 3.1. 定义变量 3.2. 自动化变量 3.3. 环境变量 3.4. 驱动器变量 3.5. 变量的作用域 3.6. 变量的类型和强类型 3.7. 变量的幕后管理 4. Powershell数组和哈希表 4.1. 命令返回数组 4.2. 创建数组 4.3. 访问数组 4.4. 复制数组 4.5. 强类型数组 4.6. 使用哈希表 5. Powershell管道 5.1. 使用管道 5.2. 对象转换成文本 5.3. 排序和分组 5.4. 过滤管道结果 5.5. 分析和比较管道结果 5.6. 导出管道结果 5.7. 扩展类型系统 6. Powershell使用对象 6.1. 对象=属性+方法 6.2. 属性（对象是什么） 6.3. 方法（对象能做什么） 6.4. 使用真实的对象工作 6.5. 调用静态方法 6.6. 创建对象 7. Powershell条件判断 7.1. 条件表达式 7.2. Where-Object 7.3. IF-ElseIf-Else 7.4. Switch 8. Powershell循环 8.1. ForEach-Object 8.2. Foreach 8.3. Do While 8.4. For 8.5. Switch 9. Powershell函数 9.1. 定义新函数 9.2. 处理函数的参数 9.3. 指定函数的返回值 9.4. 查看支持的函数 9.5. 函数 过滤器 管道 10. Powershell脚本 10.1. 编写和运行脚本 10.2. 给脚本传递参数 10.3. 增强脚本的可读性 10.4. 创建管道脚本 10.5. 自动执行脚本之profile 10.6. 脚本的数字签名 11. Powershell错误处理 11.1. what-if 11.2. 定义容错度 11.3. 识别和处理异常 11.4. 错误记录:详细错误 11.5. 理解异常 11.6. 在函数和脚本中捕获异常 11.7. 断点执行 12. Powershell命令发现和脚本块 12.1. 发现命令 12.2. 调用操作符 12.3. 使用语句块 12.4. 执行上下文 13. Powershell文本和正则表达式 13.1. 定义文本 13.2. 使用特殊文本命令 13.2.1. 字符串操作符 13.2.1.1. 格式化字符串 13.2.1.2. 设置数字格式 13.2.1.3. 固定宽度的制表输出 13.2.2. String 对象方法 13.2.3. String 类方方法 13.2.4. 简单模式匹配 13.3. 正则表达式 13.3.1. 定义模式 13.3.2. 同时搜索不同的词语 13.3.3. 大小写敏感 13.3.4. 在文本中搜索信息 13.3.5. 搜索不同的关键字 13.3.6. 组 13.3.7. 深入使用子表达式 13.3.8. 贪婪与非贪婪匹配 13.3.9. 搜索字符串片段 13.3.10. 替换字符串 13.3.11. 使用反向引用 13.3.12. 在文本行的开始插入文本 13.3.13. 删除多余的空格 13.3.14. 搜索和移除重复的单词 13.3.15. 非捕获组 13.4. 文本处理实例 13.4.1. 文本处理实例（一） 13.4.2. 文本处理实例（二） 13.4.3. 文本处理实例（三） 13.4.4. 文本处理实例（四） 14. PowerShell处理XML 14.1. XML 结构 14.2. 加载和处理XML文件 14.3. 浏览扩展类型系统 15. PowerShell文件系统 15.1. 前言 15.2. 访问文件和目录 15.3. 导航文件系统 15.4. 使用目录和文件工作 15.5. 管理访问权限 16. PowerShell注册表 16.1. 操作注册表的几条重要命令 16.2. “提供程序”文件系统以外的位置 16.3. 搜索注册表 16.4. 创建和删除键值 16.5. 注册表权限","text":"1. 认识Powershell 1.1. 介绍和安装 1.2. 自定义控制台 1.3. 快速编辑模式和标准模式 1.4. 快捷键 1.5. 管道和重定向 2. Powershell交互式 2.1. 数学运算 2.2. 执行外部命令 2.3. 命令集 2.4. 别名 2.5. 通过函数扩展别名 2.6. 执行文件和脚本 3. Powershell变量 3.1. 定义变量 3.2. 自动化变量 3.3. 环境变量 3.4. 驱动器变量 3.5. 变量的作用域 3.6. 变量的类型和强类型 3.7. 变量的幕后管理 4. Powershell数组和哈希表 4.1. 命令返回数组 4.2. 创建数组 4.3. 访问数组 4.4. 复制数组 4.5. 强类型数组 4.6. 使用哈希表 5. Powershell管道 5.1. 使用管道 5.2. 对象转换成文本 5.3. 排序和分组 5.4. 过滤管道结果 5.5. 分析和比较管道结果 5.6. 导出管道结果 5.7. 扩展类型系统 6. Powershell使用对象 6.1. 对象=属性+方法 6.2. 属性（对象是什么） 6.3. 方法（对象能做什么） 6.4. 使用真实的对象工作 6.5. 调用静态方法 6.6. 创建对象 7. Powershell条件判断 7.1. 条件表达式 7.2. Where-Object 7.3. IF-ElseIf-Else 7.4. Switch 8. Powershell循环 8.1. ForEach-Object 8.2. Foreach 8.3. Do While 8.4. For 8.5. Switch 9. Powershell函数 9.1. 定义新函数 9.2. 处理函数的参数 9.3. 指定函数的返回值 9.4. 查看支持的函数 9.5. 函数 过滤器 管道 10. Powershell脚本 10.1. 编写和运行脚本 10.2. 给脚本传递参数 10.3. 增强脚本的可读性 10.4. 创建管道脚本 10.5. 自动执行脚本之profile 10.6. 脚本的数字签名 11. Powershell错误处理 11.1. what-if 11.2. 定义容错度 11.3. 识别和处理异常 11.4. 错误记录:详细错误 11.5. 理解异常 11.6. 在函数和脚本中捕获异常 11.7. 断点执行 12. Powershell命令发现和脚本块 12.1. 发现命令 12.2. 调用操作符 12.3. 使用语句块 12.4. 执行上下文 13. Powershell文本和正则表达式 13.1. 定义文本 13.2. 使用特殊文本命令 13.2.1. 字符串操作符 13.2.1.1. 格式化字符串 13.2.1.2. 设置数字格式 13.2.1.3. 固定宽度的制表输出 13.2.2. String 对象方法 13.2.3. String 类方方法 13.2.4. 简单模式匹配 13.3. 正则表达式 13.3.1. 定义模式 13.3.2. 同时搜索不同的词语 13.3.3. 大小写敏感 13.3.4. 在文本中搜索信息 13.3.5. 搜索不同的关键字 13.3.6. 组 13.3.7. 深入使用子表达式 13.3.8. 贪婪与非贪婪匹配 13.3.9. 搜索字符串片段 13.3.10. 替换字符串 13.3.11. 使用反向引用 13.3.12. 在文本行的开始插入文本 13.3.13. 删除多余的空格 13.3.14. 搜索和移除重复的单词 13.3.15. 非捕获组 13.4. 文本处理实例 13.4.1. 文本处理实例（一） 13.4.2. 文本处理实例（二） 13.4.3. 文本处理实例（三） 13.4.4. 文本处理实例（四） 14. PowerShell处理XML 14.1. XML 结构 14.2. 加载和处理XML文件 14.3. 浏览扩展类型系统 15. PowerShell文件系统 15.1. 前言 15.2. 访问文件和目录 15.3. 导航文件系统 15.4. 使用目录和文件工作 15.5. 管理访问权限 16. PowerShell注册表 16.1. 操作注册表的几条重要命令 16.2. “提供程序”文件系统以外的位置 16.3. 搜索注册表 16.4. 创建和删除键值 16.5. 注册表权限 1. 认识Powershell 1.1. 介绍和安装 Powershell 是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境。你可以把它看成是命令行提示符cmd.exe的扩充，不对，应当是颠覆。 powershell需要.NET环境的支持，同时支持.NET对象。微软之所以将Powershell 定位为Power，并不是夸大其词，因为它完全支持对象。其可读性，易用性，可以位居当前所有shell之首。 当前powershell有四版本，分别为1.0，2.0，3.0 ,4.0 如果您的系统是window7或者Windows Server 2008，那么PowerShell 2.0已经内置了，可以升级为3.0，4.0。 如果您的系统是Windows 8 或者Windows server 2012，那么PowerShell 3.0已经内置了，可以升级为4.0。 如果您的系统为Windows 8.1或者Windows server 2012 R2，那默认已经是4.0了。 Powershell 1.0 下载地址 Powershell 2.0 下载地址 powershell3.0 介绍,下载 powershell4.0 介绍,下载 1.2. 自定义控制台 1.3. 快速编辑模式和标准模式 1.4. 快捷键 1.5. 管道和重定向 2. Powershell交互式 2.1. 数学运算 2.2. 执行外部命令 2.3. 命令集 2.4. 别名 2.5. 通过函数扩展别名 2.6. 执行文件和脚本 3. Powershell变量 3.1. 定义变量 3.2. 自动化变量 3.3. 环境变量 3.4. 驱动器变量 3.5. 变量的作用域 3.6. 变量的类型和强类型 3.7. 变量的幕后管理 4. Powershell数组和哈希表 4.1. 命令返回数组 4.2. 创建数组 4.3. 访问数组 4.4. 复制数组 4.5. 强类型数组 4.6. 使用哈希表 5. Powershell管道 5.1. 使用管道 5.2. 对象转换成文本 5.3. 排序和分组 5.4. 过滤管道结果 5.5. 分析和比较管道结果 5.6. 导出管道结果 5.7. 扩展类型系统 6. Powershell使用对象 6.1. 对象=属性+方法 6.2. 属性（对象是什么） 6.3. 方法（对象能做什么） 6.4. 使用真实的对象工作 6.5. 调用静态方法 6.6. 创建对象 7. Powershell条件判断 7.1. 条件表达式 7.2. Where-Object 7.3. IF-ElseIf-Else 7.4. Switch 8. Powershell循环 8.1. ForEach-Object 8.2. Foreach 8.3. Do While 8.4. For 8.5. Switch 9. Powershell函数 9.1. 定义新函数 9.2. 处理函数的参数 9.3. 指定函数的返回值 9.4. 查看支持的函数 9.5. 函数 过滤器 管道 10. Powershell脚本 10.1. 编写和运行脚本 10.2. 给脚本传递参数 10.3. 增强脚本的可读性 10.4. 创建管道脚本 10.5. 自动执行脚本之profile 10.6. 脚本的数字签名 11. Powershell错误处理 11.1. what-if 11.2. 定义容错度 11.3. 识别和处理异常 11.4. 错误记录:详细错误 11.5. 理解异常 11.6. 在函数和脚本中捕获异常 11.7. 断点执行 12. Powershell命令发现和脚本块 12.1. 发现命令 12.2. 调用操作符 12.3. 使用语句块 12.4. 执行上下文 13. Powershell文本和正则表达式 13.1. 定义文本 13.2. 使用特殊文本命令 13.2.1. 字符串操作符 13.2.1.1. 格式化字符串 13.2.1.2. 设置数字格式 13.2.1.3. 固定宽度的制表输出 13.2.2. String 对象方法 13.2.3. String 类方方法 13.2.4. 简单模式匹配 13.3. 正则表达式 13.3.1. 定义模式 13.3.2. 同时搜索不同的词语 13.3.3. 大小写敏感 13.3.4. 在文本中搜索信息 13.3.5. 搜索不同的关键字 13.3.6. 组 13.3.7. 深入使用子表达式 13.3.8. 贪婪与非贪婪匹配 13.3.9. 搜索字符串片段 13.3.10. 替换字符串 13.3.11. 使用反向引用 13.3.12. 在文本行的开始插入文本 13.3.13. 删除多余的空格 13.3.14. 搜索和移除重复的单词 13.3.15. 非捕获组 13.4. 文本处理实例 13.4.1. 文本处理实例（一） 13.4.2. 文本处理实例（二） 13.4.3. 文本处理实例（三） 13.4.4. 文本处理实例（四） 14. PowerShell处理XML 14.1. XML 结构 14.2. 加载和处理XML文件 14.3. 浏览扩展类型系统 15. PowerShell文件系统 15.1. 前言 15.2. 访问文件和目录 15.3. 导航文件系统 15.4. 使用目录和文件工作 15.5. 管理访问权限 16. PowerShell注册表 16.1. 操作注册表的几条重要命令 16.2. “提供程序”文件系统以外的位置 16.3. 搜索注册表 16.4. 创建和删除键值 16.5. 注册表权限","categories":[],"tags":[],"author":[{"name":"Mooser Lee","homepage":"https://www.pstips.net/author/mosser","photo":"g.jpg"}]},{"title":"Android信号强度转换","slug":"Android/Android信号强度转换","date":"2020-01-03T06:58:15.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/640264113/","link":"","permalink":"https://cyriltaylor.github.io/posts/640264113/","excerpt":"","text":"","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"U-Boot启动流程分析","slug":"Bootloader/U-Boot启动流程分析","date":"2019-12-10T08:04:21.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/4029236758/","link":"","permalink":"https://cyriltaylor.github.io/posts/4029236758/","excerpt":"","text":"Environment加载流程分析","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Shell图形化","slug":"Shell/Shell图形化","date":"2019-11-21T08:52:32.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3842726194/","link":"","permalink":"https://cyriltaylor.github.io/posts/3842726194/","excerpt":"","text":"whiptail Internal colour palette of whiptail may be overwritten at compilation by providing a path to a file containing color definitions. In ubuntu sudo update-alternatives --config newt-palette provides a way of selecting between ubuntu palette and original palette. The location of this file can be overriden by setting the NEWT_COLORS_FILE to point to an alternative file. Furthermore both previous overrides can be overriden by setting the NEWT_COLORS environment variable. The structure of the definitions is: 1name=[fg],[bg][;|:|\\n|\\r|\\t]name2=[fg],[bg]]... name can be: 1234567891011121314151617181920212223root root fg, bgborder border fg, bgwindow window fg, bgshadow shadow fg, bgtitle title fg, bgbutton button fg, bgactbutton active button fg, bgcheckbox checkbox fg, bgactcheckbox active checkbox fg, bgentry entry box fg, bglabel label fg, bglistbox listbox fg, bgactlistbox active listbox fg, bgtextbox textbox fg, bgacttextbox active textbox fg, bghelpline help lineroottext root textemptyscale scale fullfullscale scale emptydisentry disabled entry fg, bgcompactbutton compact button fg, bgactsellistbox active &amp; sel listboxsellistbox selected listbox bg and fg can be: 12345678910111213141516color0 or blackcolor1 or redcolor2 or greencolor3 or browncolor4 or bluecolor5 or magentacolor6 or cyancolor7 or lightgraycolor8 or graycolor9 or brightredcolor10 or brightgreencolor11 or yellowcolor12 or brightbluecolor13 or brightmagentacolor14 or brightcyancolor15 or white Example displaying a message box with red window background: 123456789#!/bin/shNEWT_COLORS=&#x27; window=,red border=white,red textbox=white,red button=black,white&#x27; \\whiptail --msgbox &quot;passwords don&#x27;t match&quot; 0 0 Appending to ubuntu colors: 12345678910111213#!/bin/bashreadarray -t newtcols &lt; /etc/newt/palettenewtcols_error=( window=,red border=white,red textbox=white,red button=black,white)NEWT_COLORS=&quot;$&#123;newtcols[@]&#125; $&#123;newtcols_error[@]&#125;&quot; \\whiptail --msgbox &quot;passwords don&#x27;t match&quot; 0 0","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"UML建模详解","slug":"Tools/UML建模详解","date":"2019-11-15T03:13:38.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/916534012/","link":"","permalink":"https://cyriltaylor.github.io/posts/916534012/","excerpt":"","text":"UML活动图 启动SD卡刷机程序读取分区表文件读取下一个节点的属性是否存在起始地址存在不存在将起始地址转为unit数保存起始地址计算分区起始地址将起始地址转为unit数保存起始地址存在上一个节点是否存在起始地址不存在无效起始地址是否有效有效对应的镜像文件是否存在存在不存在镜像文件哈希值匹配？匹配不匹配打印错误信息，并设置信号灯为常亮红色存在是否存在需下载的镜像文件不存在最后一个节点？否按照分区起始地址递增排序成功文件读取成功？失败存在分区表文件存在？不存在打印错误信息，并设置信号灯为常亮红色","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"PySide2 API","slug":"Python/PySide2API","date":"2019-10-25T10:12:09.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/99546601/","link":"","permalink":"https://cyriltaylor.github.io/posts/99546601/","excerpt":"","text":"PySide2 Qt ModulesAPI","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"git命令详解","slug":"Shell/git命令详解","date":"2019-10-23T06:31:42.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3542554366/","link":"","permalink":"https://cyriltaylor.github.io/posts/3542554366/","excerpt":"","text":"log 查看两个commits之间的提交 1git log --pretty=oneline tagA...tagB submodule git子模块允许在git工程子目录下包含一个或者多个git工程，并且可以用通过主目录的git进行管理，而各个子模块也可以保持本身git仓库的独立提交管理。","categories":[{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/tags/shell/"},{"name":"git","slug":"git","permalink":"https://cyriltaylor.github.io/tags/git/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"终极学习法--费曼技巧(The Feynman Technique)","slug":"杂记/费曼学习法","date":"2019-10-22T06:52:50.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/2254807049/","link":"","permalink":"https://cyriltaylor.github.io/posts/2254807049/","excerpt":"","text":"知识有两种类型，一种是注重了解事物的名称，可以认为是认知的过程；一类是注重了解事物本身，可以认为是理解的过程。","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Linux内核驱动-GPIO","slug":"Linux/Linux内核驱动-GPIO","date":"2019-10-18T03:01:01.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/4193374346/","link":"","permalink":"https://cyriltaylor.github.io/posts/4193374346/","excerpt":"","text":"/sys/kernel/debug/pinctrl echo 238 &gt; /sys/class/gpio/export; echo out &gt; /sys/class/gpio/gpio238/direction; echo 1 &gt; /sys/class/gpio/gpio238/value minicom输入命令 : local Echo on(Ctrl+A-&gt;Z-&gt;E) Port Config(Ctrl+A-&gt;Z-&gt;E) F - Hardware Flow Control: NO G - Software Flow Control : No","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/tags/Linux/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://cyriltaylor.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"},{"name":"GPIO","slug":"GPIO","permalink":"https://cyriltaylor.github.io/tags/GPIO/"},{"name":"Pinctrl","slug":"Pinctrl","permalink":"https://cyriltaylor.github.io/tags/Pinctrl/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Linux内核驱动调试","slug":"Linux/Linux内核驱动调试","date":"2019-10-14T11:00:02.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1458029102/","link":"","permalink":"https://cyriltaylor.github.io/posts/1458029102/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[ 391.911450] Unable to handle kernel NULL pointer dereference at virtual address 00000018[ 391.919552] pgd &#x3D; e8ca0f1c[ 391.922256] [00000018] *pgd&#x3D;6da5e003, *pmd&#x3D;be8c2003[ 391.927137] Internal error: Oops: 207 [#1] SMP ARM[ 391.931921] Modules linked in: asix usbnet btrfs nls_ascii zstd_compress brcmfmac raid6_pq brcmutil libcrc32c cfg80211 lzo_compress zlib_deflate zstd_decompress xxhash g_mass_storage[ 391.948192] CPU: 1 PID: 2000 Comm: cat Not tainted 4.19.69-g37208387d-dirty #8[ 391.955403] Hardware name: Allwinner sun8i Family[ 391.960115] PC is at serial_sunxi_modem_status+0xc&#x2F;0xdc[ 391.965336] LR is at serial_sunxi_get_mctrl+0xc&#x2F;0x60[ 391.970294] pc : [&lt;c05f9078&gt;] lr : [&lt;c05f9154&gt;] psr: 600e0093[ 391.976551] sp : ee88dde8 ip : 00000015 fp : ede50058[ 391.981768] r10: 00000004 r9 : c1062d88 r8 : ee869c74[ 391.986987] r7 : 00000004 r6 : 000003e0 r5 : c10633f0 r4 : c10633f0[ 391.993503] r3 : 00000000 r2 : 00000002 r1 : 00000000 r0 : c10633f0[ 392.000023] Flags: nZCv IRQs off FIQs on Mode SVC_32 ISA ARM Segment none[ 392.007234] Control: 30c5387d Table: 684fa2c0 DAC: 344ff332[ 392.012973] Process cat (pid: 2000, stack limit &#x3D; 0x4c81470b)[ 392.018712] Stack: (0xee88dde8 to 0xee88e000)[ 392.023067] dde0: c10633f0 c10633f0 000003e0 c05f9154 c10633f0 ee869be0[ 392.031235] de00: 000003e0 c05eea60 c0b77c10 00000040 00000000 00000000 00000000 00000000[ 392.039404] de20: c1008d14 00000000 c0b77c44 c0b77c10 c0b77c18 c1008d14 00000fb8 ffeee000[ 392.047572] de40: d2eb0f8f ee868800 dc7678f0 00000055 006000c0 000b6bf7 b6bf7000 d2eb0f8f[ 392.055740] de60: e84fa2d0 ede50058 00000001 007000c0 ee88df78 b6bf8000 00000000 00000000[ 392.063907] de80: ece8ccc0 c037f250 dc7678f0 ede50070 00020000 b6bf8000 ede50088 ece1d480[ 392.072076] dea0: 00000a06 ee983600 c037f054 00000000 ee88df78 b6bf8000 00000000 00020000[ 392.080244] dec0: 00020000 c03c38bc c1008d14 ece8ccc0 c03c384c c035a888 00000000 c1008d14[ 392.088413] dee0: 00000a06 b6bf7004 c100e734 ee88dfb0 00002710 b6f01000 b6ee5120 c02310b8[ 392.096582] df00: 00022000 00022000 b6bf7000 00000022 00000003 00000000 00000073 dc114200[ 392.104750] df20: 00000022 d2eb0f8f 000b6bf7 00020000 ece8ccc0 ffffe000 ee88df78 b6bf8000[ 392.112918] df40: 00000000 00020000 00020000 c035aa40 00022000 00000003 b6ee5120 ece8ccc0[ 392.121086] df60: c1008d14 ece8ccc0 b6bf8000 00000000 00000000 c035b000 00000000 00000000[ 392.129254] df80: ee88df7c d2eb0f8f 00020000 7fffe000 000165d0 00000003 c0201324 ee88c000[ 392.137423] dfa0: 00000003 c0201120 00020000 7fffe000 00000003 b6bf8000 00020000 000271c4[ 392.145592] dfc0: 00020000 7fffe000 000165d0 00000003 00000003 00000000 00000000 00020000[ 392.153759] dfe0: 00000000 bec97ab4 0001396d b6ea0f16 000e0030 00000003 00000000 00000000[ 392.161942] [&lt;c05f9078&gt;] (serial_sunxi_modem_status) from [&lt;c05f9154&gt;] (serial_sunxi_get_mctrl+0xc&#x2F;0x60)[ 392.171417] [&lt;c05f9154&gt;] (serial_sunxi_get_mctrl) from [&lt;c05eea60&gt;] (uart_proc_show+0x1ac&#x2F;0x40c)[ 392.180199] [&lt;c05eea60&gt;] (uart_proc_show) from [&lt;c037f250&gt;] (seq_read+0x1fc&#x2F;0x478)[ 392.187768] [&lt;c037f250&gt;] (seq_read) from [&lt;c03c38bc&gt;] (proc_reg_read+0x70&#x2F;0x88)[ 392.195078] [&lt;c03c38bc&gt;] (proc_reg_read) from [&lt;c035a888&gt;] (__vfs_read+0x2c&#x2F;0x154)[ 392.202644] [&lt;c035a888&gt;] (__vfs_read) from [&lt;c035aa40&gt;] (vfs_read+0x90&#x2F;0x154)[ 392.209776] [&lt;c035aa40&gt;] (vfs_read) from [&lt;c035b000&gt;] (ksys_read+0x60&#x2F;0xc0)[ 392.216735] [&lt;c035b000&gt;] (ksys_read) from [&lt;c0201120&gt;] (ret_fast_syscall+0x0&#x2F;0x4c)[ 392.224293] Exception stack(0xee88dfa8 to 0xee88dff0)[ 392.229341] dfa0: 00020000 7fffe000 00000003 b6bf8000 00020000 000271c4[ 392.237509] dfc0: 00020000 7fffe000 000165d0 00000003 00000003 00000000 00000000 00020000[ 392.245674] dfe0: 00000000 bec97ab4 0001396d b6ea0f16[ 392.250725] Code: c0a4cb30 e92d4070 e1a05000 e5903008 (e5d34018) [ 392.256813] ---[ end trace fa9691d56c9fdb90 ]---[ 392.261425] Kernel panic - not syncing: Fatal exception[ 392.266656] CPU2: stopping[ 392.269375] CPU: 2 PID: 0 Comm: swapper&#x2F;2 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.278232] Hardware name: Allwinner sun8i Family[ 392.282946] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10&#x2F;0x14)[ 392.290689] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84&#x2F;0x98)[ 392.297907] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4&#x2F;0x19c)[ 392.305213] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74&#x2F;0x78)[ 392.312778] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58&#x2F;0x74)[ 392.320249] Exception stack(0xee89bf58 to 0xee89bfa0)[ 392.325294] bf40: 00000000 002ee53c[ 392.333462] bf60: eedcd670 c0236200 ee89a000 c1008d48 c1008d90 00000004 00000000 00000000[ 392.341631] bf80: c0e6aa70 ee89bfb0 c1008d48 ee89bfa8 c02264dc c02264e0 60010013 ffffffff[ 392.349802] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34&#x2F;0x38)[ 392.357195] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150&#x2F;0x290)[ 392.364585] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18&#x2F;0x1c)[ 392.372148] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;4020240c&gt;] (0x4020240c)[ 392.379100] CPU0: stopping[ 392.381810] CPU: 0 PID: 0 Comm: swapper&#x2F;0 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.390666] Hardware name: Allwinner sun8i Family[ 392.395372] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10&#x2F;0x14)[ 392.403111] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84&#x2F;0x98)[ 392.410327] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4&#x2F;0x19c)[ 392.417631] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74&#x2F;0x78)[ 392.425194] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58&#x2F;0x74)[ 392.432665] Exception stack(0xc1001f00 to 0xc1001f48)[ 392.437714] 1f00: 00000000 007016cc eedab670 c0236200 c1000000 c1008d48 c1008d90 00000001[ 392.445882] 1f20: 00000000 00000000 c0e6aa70 c1001f58 c1008d48 c1001f50 c02264dc c02264e0[ 392.454046] 1f40: 600e0013 ffffffff[ 392.457535] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34&#x2F;0x38)[ 392.464925] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150&#x2F;0x290)[ 392.472315] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18&#x2F;0x1c)[ 392.479880] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;c0e00d10&gt;] (start_kernel+0x41c&#x2F;0x444)[ 392.488046] CPU3: stopping[ 392.490756] CPU: 3 PID: 0 Comm: swapper&#x2F;3 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.499612] Hardware name: Allwinner sun8i Family[ 392.504318] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10&#x2F;0x14)[ 392.512057] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84&#x2F;0x98)[ 392.519273] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4&#x2F;0x19c)[ 392.526576] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74&#x2F;0x78)[ 392.534140] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58&#x2F;0x74)[ 392.541611] Exception stack(0xee89df58 to 0xee89dfa0)[ 392.546655] df40: 00000000 0011eb94[ 392.554824] df60: eedde670 c0236200 ee89c000 c1008d48 c1008d90 00000008 00000000 00000000[ 392.562992] df80: c0e6aa70 ee89dfb0 c1008d48 ee89dfa8 c02264dc c02264e0 600f0013 ffffffff[ 392.571162] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34&#x2F;0x38)[ 392.578552] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150&#x2F;0x290)[ 392.585942] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18&#x2F;0x1c)[ 392.593504] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;4020240c&gt;] (0x4020240c)[ 392.600462] Rebooting in 10 seconds.. 123456789prebuilts/gcc/linux-x86/arm/arm-eabi-6.3.1/bin/arm-eabi-nm out/linux-maxtropy_mxfitow_defconfig/vmlinux | grep -nir &quot;serial_sunxi_modem_status&quot;Binary file out/linux-maxtropy_mxfitow_defconfig/vmlinux matchesout/linux-maxtropy_mxfitow_defconfig/.tmp_System.map:18523:c05f906c t serial_sunxi_modem_statusout/linux-maxtropy_mxfitow_defconfig/System.map:18523:c05f906c t serial_sunxi_modem_statusprebuilts/gcc/linux-x86/arm/arm-eabi-6.3.1/bin/arm-eabi-addr2line -afispe out/linux-maxtropy_mxfitow_defconfig/vmlinux c05f90780xc05f9078: __raw_readb at io.h:108 (inlined by) serial_in at serial_sunxi.c:155 (inlined by) serial_sunxi_modem_status at serial_sunxi.c:333 12345678910111213141516Usage: prebuilts&#x2F;gcc&#x2F;linux-x86&#x2F;arm&#x2F;arm-eabi-6.3.1&#x2F;bin&#x2F;arm-eabi-addr2line [option(s)] [addr(s)] Convert addresses into line number&#x2F;file name pairs. If no addresses are specified on the command line, they will be read from stdin The options are: @&lt;file&gt; Read options from &lt;file&gt; -a --addresses Show addresses -b --target&#x3D;&lt;bfdname&gt; Set the binary file format -e --exe&#x3D;&lt;executable&gt; Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section&#x3D;&lt;name&gt; Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[&#x3D;style] Demangle function names -h --help Display this information -v --version Display the program&#39;s version","categories":[],"tags":[],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Linux内核API参考手册","slug":"Linux/Linux内核API参考手册","date":"2019-10-12T07:42:16.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3397013201/","link":"","permalink":"https://cyriltaylor.github.io/posts/3397013201/","excerpt":"GPIO","text":"GPIO GPIO","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/tags/Linux/"},{"name":"kernel API","slug":"kernel-API","permalink":"https://cyriltaylor.github.io/tags/kernel-API/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Java进阶","slug":"Java/Java进阶","date":"2019-10-10T15:33:52.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1503406261/","link":"","permalink":"https://cyriltaylor.github.io/posts/1503406261/","excerpt":"1. 抽象类与接口 try…catch…finally执行顺序及返回值 2. 集合框架 2.1. List 2.2. Map 2.3. Set 2.4. Queue 3. 异常和Error 4. 类加载过程 5. 泛型 6. 反射 7. 注解 8. 互斥锁 8.1. 乐观锁与悲观锁 8.2. 自旋锁","text":"1. 抽象类与接口 try…catch…finally执行顺序及返回值 2. 集合框架 2.1. List 2.2. Map 2.3. Set 2.4. Queue 3. 异常和Error 4. 类加载过程 5. 泛型 6. 反射 7. 注解 8. 互斥锁 8.1. 乐观锁与悲观锁 8.2. 自旋锁 1. 抽象类与接口 抽象类 抽象类由关键字abstract修饰，且必须是public(默认)或protected类型，不可以是private(无法被子类继承)类型，也不能定义为final类型 抽象类不能被实例化，只能实例化其非抽象类子类 抽象类是一类特殊的类，它除了声明为抽象类，包含抽象方法外，其他功能跟普通类一样，可以定义函数和变量，并在抽象类或者子类中使用 抽象类中的抽象方法必须由子类重写，而普通方法则不需要子类重新；如果子类没有完全实现抽象类的所有抽象方法，则该子类也要声明为抽象类 子类中的抽象方法不能与父类中的抽象方法同名 抽象方法只是函数声明，不能包含具体实现，具体实现必须由子类实现 抽象方法不能声明为private、static、final或者native类型 子类只能继承一个抽象类 接口 接口不是类，而是一系列常量或者方法的集合 接口由interface声明，并通过implements被其他类继承 接口的所有方法均被自动声明为public，成员“变量”均被自动声明为public static final类型 接口中不能包含任何具体的方法实现，全部都是方法声明 implement接口的非抽象类必须实现接口的所有方法，而implement接口的抽象类则可以不实现或者实现部分方法 接口不能通过new等方式实例化，但是可以用于声明变量，该变量只能指向实现了该接口的类，并可以通过instanceof检查变量是否是接口的实例 同时作用于一个类的多个接口不能包含重名的方法 一个类可以实现多个接口 try…catch…finally执行顺序及返回值 https://blog.csdn.net/stypace/article/details/42102181 2. 集合框架 Java集合框架 2.1. List 2.2. Map 2.3. Set 2.4. Queue 3. 异常和Error 4. 类加载过程 5. 泛型 6. 反射 7. 注解 8. 互斥锁 8.1. 乐观锁与悲观锁 8.2. 自旋锁","categories":[{"name":"Java","slug":"Java","permalink":"https://cyriltaylor.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cyriltaylor.github.io/tags/Java/"},{"name":"高级特性","slug":"高级特性","permalink":"https://cyriltaylor.github.io/tags/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"C++进阶","slug":"C++/C++进阶","date":"2019-10-10T13:37:02.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1473815809/","link":"","permalink":"https://cyriltaylor.github.io/posts/1473815809/","excerpt":"1. ASCII码表 1.1. ASCII控制字符 1.2. ASCII可显示字符 2. 运算符优先级表 3. 程序虚拟存储器 3.1. 只读存储区 3.2. 堆/栈对比 3.3. 自由存储区 4. new和malloc的区别 5. 关键字static、const、volatile 5.1. static 5.1.1. 面向过程设计中的static 5.2. 面向对象设计中的static 5.3. const 5.3.1. const修饰成员变量 5.3.2. const修饰函数参数 5.3.3. const修饰成员函数 5.3.4. const修饰函数返回值 5.4. volatile 5.4.1. volatile的作用 5.4.2. volatile指针 5.5. 多线程下的volatile 6. C和C++相互调用 6.1. C++中调用C 6.2. C中调用C++ 7. 参考文献","text":"1. ASCII码表 1.1. ASCII控制字符 1.2. ASCII可显示字符 2. 运算符优先级表 3. 程序虚拟存储器 3.1. 只读存储区 3.2. 堆/栈对比 3.3. 自由存储区 4. new和malloc的区别 5. 关键字static、const、volatile 5.1. static 5.1.1. 面向过程设计中的static 5.2. 面向对象设计中的static 5.3. const 5.3.1. const修饰成员变量 5.3.2. const修饰函数参数 5.3.3. const修饰成员函数 5.3.4. const修饰函数返回值 5.4. volatile 5.4.1. volatile的作用 5.4.2. volatile指针 5.5. 多线程下的volatile 6. C和C++相互调用 6.1. C++中调用C 6.2. C中调用C++ 7. 参考文献 1. ASCII码表 1.1. ASCII控制字符 二进制 十进制 十六进制 缩写 可以显示的表示法 名称/意义 0000 0000 0 00 NUL ␀ 空字符（Null） 0000 0001 1 01 SOH ␁ 标题开始 0000 0010 2 02 STX ␂ 本文开始 0000 0011 3 03 ETX ␃ 本文结束 0000 0100 4 04 EOT ␄ 传输结束 0000 0101 5 05 ENQ ␅ 请求 0000 0110 6 06 ACK ␆ 确认回应 0000 0111 7 07 BEL ␇ 响铃 0000 1000 8 08 BS ␈ 退格 0000 1001 9 09 HT ␉ 水平定位符号 0000 1010 10 0A LF ␊ 换行键 0000 1011 11 0B VT ␋ 垂直定位符号 0000 1100 12 0C FF ␌ 换页键 0000 1101 13 0D CR ␍ 归位键 0000 1110 14 0E SO ␎ 取消变换（Shift out） 0000 1111 15 0F SI ␏ 启用变换（Shift in） 0001 0000 16 10 DLE ␐ 跳出数据通讯 0001 0001 17 11 DC1 ␑ 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 ␒ 设备控制二 0001 0011 19 13 DC3 ␓ 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 ␔ 设备控制四 0001 0101 21 15 NAK ␕ 确认失败回应 0001 0110 22 16 SYN ␖ 同步用暂停 0001 0111 23 17 ETB ␗ 区块传输结束 0001 1000 24 18 CAN ␘ 取消 0001 1001 25 19 EM ␙ 连接介质中断 0001 1010 26 1A SUB ␚ 替换 0001 1011 27 1B ESC ␛ 跳出 0001 1100 28 1C FS ␜ 文件分割符 0001 1101 29 1D GS ␝ 组群分隔符 0001 1110 30 1E RS ␞ 记录分隔符 0001 1111 31 1F US ␟ 单元分隔符 0111 1111 127 7F DEL ␡ 删除 1.2. ASCII可显示字符 二进制 十进制 十六进制 图形 0010 0000 32 20 （空格）(␠) 0010 0001 33 21 ! 0010 0010 34 22 &quot; 0010 0011 35 23 # 0010 0100 36 24 $ 0010 0101 37 25 % 0010 0110 38 26 &amp; 0010 0111 39 27 ’ 0010 1000 40 28 ( 0010 1001 41 29 ) 0010 1010 42 2A * 0010 1011 43 2B + 0010 1100 44 2C , 0010 1101 45 2D - 0010 1110 46 2E . 0010 1111 47 2F / 0011 0000 48 30 0 0011 0001 49 31 1 0011 0010 50 32 2 0011 0011 51 33 3 0011 0100 52 34 4 0011 0101 53 35 5 0011 0110 54 36 6 0011 0111 55 37 7 0011 1000 56 38 8 0011 1001 57 39 9 0011 1010 58 3A : 0011 1011 59 3B ; 0011 1100 60 3C &lt; 0011 1101 61 3D = 0011 1110 62 3E &gt; 0011 1111 63 3F ? 0100 0000 64 40 @ 0100 0001 65 41 A 0100 0010 66 42 B 0100 0011 67 43 C 0100 0100 68 44 D 0100 0101 69 45 E 0100 0110 70 46 F 0100 0111 71 47 G 0100 1000 72 48 H 0100 1001 73 49 I 0100 1010 74 4A J 0100 1011 75 4B K 0100 1100 76 4C L 0100 1101 77 4D M 0100 1110 78 4E N 0100 1111 79 4F O 0101 0000 80 50 P 0101 0001 81 51 Q 0101 0010 82 52 R 0101 0011 83 53 S 0101 0100 84 54 T 0101 0101 85 55 U 0101 0110 86 56 V 0101 0111 87 57 W 0101 1000 88 58 X 0101 1001 89 59 Y 0101 1010 90 5A Z 0101 1011 91 5B [ 0101 1100 92 5C \\ 0101 1101 93 5D ] 0101 1110 94 5E ^ 0101 1111 95 5F _ 0110 0000 96 60 ` 0110 0001 97 61 a 0110 0010 98 62 b 0110 0011 99 63 c 0110 0100 100 64 d 0110 0101 101 65 e 0110 0110 102 66 f 0110 0111 103 67 g 0110 1000 104 68 h 0110 1001 105 69 i 0110 1010 106 6A j 0110 1011 107 6B k 0110 1100 108 6C l 0110 1101 109 6D m 0110 1110 110 6E n 0110 1111 111 6F o 0111 0000 112 70 p 0111 0001 113 71 q 0111 0010 114 72 r 0111 0011 115 73 s 0111 0100 116 74 t 0111 0101 117 75 u 0111 0110 118 76 v 0111 0111 119 77 w 0111 1000 120 78 x 0111 1001 121 79 y 0111 1010 122 7A z 0111 1011 123 7B { 0111 1100 124 7C | 0111 1101 125 7D } 0111 1110 126 7E ~ 2. 运算符优先级表 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 … () 圆括号 （表达式）/函数名(形参表) … … . 成员选择（对象） 对象.成员名 … … -&gt; 成员选择（指针） 对象指针-&gt;成员名 … 2 - 负号运算符 -表达式 右到左 单目运算符 … (类型) 强制类型转换 (数据类型)表达式 … … ++ 自增运算符 ++ 变量名/变量名++ … 单目运算符 … – 自减运算符 –变量名/变量名– … 单目运算符 … * 取值运算符 *指针变量 … 单目运算符 … &amp; 取地址运算符 &amp;变量名 … 单目运算符 … ! 逻辑非运算符 !表达式 … 单目运算符 … ~ 按位取反运算符 ~表达式 … 单目运算符 … sizeof 长度运算符 sizeof(表达式) … 3 / 除 表达式/表达式 左到右 双目运算符 … * 乘 表达式*表达式 … 双目运算符 … % 余数（取模） 整型表达式/整型表达式 … 双目运算符 4 + 加 表达式+表达式 左到右 双目运算符 … - 减 表达式-表达式 … 双目运算符 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目运算符 … &gt;&gt; 右移 变量&gt;&gt;表达式 … 双目运算符 6 &gt; 大于 表达式&gt;表达式 左到右 双目运算符 … &gt;= 大于等于 表达式&gt;=表达式 … 双目运算符 … &lt; 小于 表达式&lt;表达式 … 双目运算符 … &lt;= 小于等于 表达式&lt;=表达式 … 双目运算符 7 == 等于 表达式==表达式 左到右 双目运算符 … != 不等于 表达式!= 表达式 … 双目运算符 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ?: 条件运算符 表达式1? 表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 … /= 除后赋值 变量/=表达式 … … *= 乘后赋值 变量*=表达式 … … %= 取模后赋值 变量%=表达式 … … += 加后赋值 变量+=表达式 … … -= 减后赋值 变量-=表达式 … … &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 … … &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 … … &amp;= 按位与后赋值 变量&amp;=表达式 … … ^= 按位异或后赋值 变量^=表达式 … … |= 按位或后赋值 变量|=表达式 … 15 , 逗号运算符 表达式,表达式,… 左到右 从左向右顺序运算 3. 程序虚拟存储器 3.1. 只读存储区 只读存储区是在编译阶段就由编译器分配好的空间，其空间大小也在编译的时候已经固定，主要包括如下分区： 程序文本(.text) 该区域包含程序代码和文字常量。 常量指值不可改变的量，在C/C++中常量分为两种，文字常量（Literal Constant）和常变量（Constant Variable）。文字常量编译之后存储在代码段，不可寻址，常变量存储在数据区（堆、栈、BSS段或数据段），可寻址。 文字常量 文字常量又称为“字面常量”，包括数值常量、字符常量和符号常量。其特点是编译后写在代码区，不可寻址，不可更改，属于指令的一部分。 12int&amp; r=5; // 编译错误，文字常量不可寻址，因而无法为文字常量建立引用const int&amp; r=5; // 编译通过，在数据区开辟一个值为5的无名整型常变量，然后将引用r与这个整型常变量进行绑定。 数值常量 包括整型常量和实型常量。整型常量指常整数，有十进制、八进制、十六进制三种表示形式。实型常量包括单精度浮点数（float）、双精度浮点数（double）和长双精度浮点数（long double），表示形式有科学计数法和非科学计数法。 123int a=4; // 4为数值常量中的整型常量float b=4.4; // 4.4为数值常量中单精度实型常量double c=1.4e10; // 1.4e5表示的值为1.4×10^5，是数值常量中双精度实型常量 字符常量 指ASCII字符，有128个，分为普通字符和转义字符。普通字符指可直接书写的字符，如’a’和’b’。转义字符指不能直接书写的特殊字符，需要使用反斜杠进行表示，比如’\\t’表示水平制表符，’\\v’表示垂直制表符。 符号常量 用标识符代表一个常量，使用之前必须定义。例如宏定义和枚举元素。 12#define NUM 100 // NUM为符号常量，100为整型常量enum Weekday&#123;SUN, MON, TUES, WED, THU, FRI, SAT&#125;; // SUN,MON等均为符号常量 常变量 常变量指定义时必须显示初始化且值不可修改的变量。与其他变量一样被分配空间，是可以寻址的。注意，字符串常量是常变量的一种，名称为其本身，存储在代码段，可寻址，不可修改。 1cout&lt;&lt;&amp;”hello world”&lt;&lt;endl; //打印输出字符串常量”hello world”存储地址 常变量在C/C++中由const关键字来定义，分为全局常变量和局部常变量。二者的区别在于：全局常变量存储在代码段的只读内存区域，不可修改有操作系统来保障，局部常变量存储在栈区，在编程语言语义层面上由编辑器做语法检查来保障其值不可修改，因不是放在只读内存中，可以获得局部常变量的地址，运行时间接进行修改。参考如下代码： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int con1=3;void showValue(const int&amp; i)&#123; cout&lt;&lt;i&lt;&lt;endl;&#125;int main(int argc,char* argv[])&#123; const int con2=4; int* ptr=NULL; ptr=const_cast&lt;int*&gt;(&amp;con2); *ptr=5; showValue(con2); //1，输出5 cout&lt;&lt;&quot;con2:&quot;&lt;&lt;con2&lt;&lt;endl; //2，输出4 ptr= const_cast&lt;int*&gt;(&amp;con1); *ptr=6; //3，运行时错误，写入冲突&#125; 程序1处输出5，表明局部常量con2的值已经被修改，2处输出为结果仍然为4，并不是说明常变量con2的值没有被修改，而是因为编译器在代码优化的过程中已经将con2替换成了文字常量4。程序3处，运行时出错，表明全局常变量存储在只读内存，无法间接改写。 已初始化数据(.data) 包含已初始化的全局变量和静态变量，程序结束后由系统释放资源。 未初始化数据(.bss) 包含为初始化的全局变量和静态变量，并且以0填充变量数值，程序结束后由系统释放资源。 3.2. 堆/栈对比 特性 堆 栈 内存管理 通过函数malloc主动申请，需要程序主动释放，或者等待程序完全退出后由系统回收 用于存放函数的形参、局部变量等，生命周期结束后由操作系统自动分配释放 空间大小 可用空间即为虚拟内存的可用空间大小 可用空间远小于堆空间大小，如64位windows程序提供的是1MB，Linux是10MB 分配方式 均为通过malloc动态分配 分为静态分配和动态分配。静态分配由操作系统完成，如局部变量；动态分配通过alloca进行动态申请，生命周期结束后由系统自动释放，无需程序主动释放。 分配效率 堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。因而分配效率比较低 栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 增长方向 向上增长，内存地址由低到高 向下增长，内存地址由高到低 存放内容 一般堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。 栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。 3.3. 自由存储区 自由存储区是C++上为new方法提供的一个抽象概念，具体对应的存储区域取决于编译器对于new方法的实现，自由存储区可能是映射到堆，也可能是映射到静态存储区，甚至可能不会重新分配内存，而仅仅只是将定位new所指定的地址返回，对于绝大部分的编译器来说，都是借助malloc来实现new操作符的功能，此时，自由存储区就是堆，而开发者可以通过重载操作符的方式重载new，此时就要依据开发者的实现来决定自由存储所对应的存储区域，例如如下的定位new表达式就是仅仅返回已定义的空间地址，而没有重新分配地址，具体可参考new和malloc的区别。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;char addr1[100];int main()&#123; char addr2[100]; char *addr3 = new char[100]; cout &lt;&lt; &quot;addr1 = &quot; &lt;&lt; (void*)addr1 &lt;&lt; endl; cout &lt;&lt; &quot;addr2 = &quot; &lt;&lt; (void*)addr2 &lt;&lt; endl; cout &lt;&lt; &quot;addr3 = &quot; &lt;&lt; (void*)addr3 &lt;&lt; endl; int *p = nullptr; // 返回静态区地址，并按地址右侧数据类型初始化该区域 p = new(addr1)int; *p = 1; cout &lt;&lt; (void*)p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; endl; // 返回栈区地址，并按地址右侧数据类型初始化该区域 p = new(addr2)int; *p = 2; cout &lt;&lt; (void*)p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; endl; //返回堆区地址，并按地址右侧数据类型初始化该区域 p = new(addr3)int; *p = 3; cout &lt;&lt; (void*)p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; endl; cin.get(); return 0;&#125; 4. new和malloc的区别 细说new与malloc的10点区别 5. 关键字static、const、volatile 5.1. static 5.1.1. 面向过程设计中的static 静态全局变量 静态全局变量如下特点： 静态全局变量数据存储在静态存储区，所以在编译时编译器将对其进行初始化，默认初始化为0，自动变量初始化为随机值 静态全局变量、静态局部变量与全局变量一样，在编译时编译器将对其进行唯一的一次初始化，程序开始运行时，静态存储区会拷贝到内存中 作用域为定义的位置到文件末尾，其他文件不可访问，用extern在其他文件引用时会运行时失败，全局变量可以在多个文件中引用 与全局变量一样，生命周期为进程的整个运行时，进程不退出，其占用的内存地址不会销毁，记录的值依旧有效 静态局部变量 静态全局变量数据存储在静态存储区，所以在编译时编译器将对其进行初始化，默认初始化为0，自动变量初始化为随机值 在编译时编译器将对其进行唯一的一次初始化，程序开始运行时，静态存储区会拷贝到内存中 只能被其同一作用域内的函数或者变量引用，作用域范围与局部变量相同 与全局变量一样，生命周期为进程的整个运行时，进程不退出，即使其作用域已执行完，其占用的内存地址不会销毁，记录的值依旧有效，下次读取到的依旧是上次修改后的值 静态函数 作用域为定义的位置到文件末尾，其他文件不可访问，而普通函数则可以被其他源文件引用 静态函数在内存中只拷贝一份，而普通函数在每次调用是都会拷贝一次 总结： 对象 存储区 作用域 生命周期 全局变量 .data字段(未初始化时编译器自动赋值) 全部源文件均可访问，其他源文件访问需要加extern关键字 进程运行开始到进程完全退出 静态全局变量 .data字段(未初始化时编译器自动赋值) 当前源文件定义处至文件末尾，其他源文件不可访问 进程运行开始到进程完全退出 静态局部变量 .data字段(未初始化时编译器自动赋值) 当前源文件定义处的作用域内 进程运行开始到进程完全退出 局部变量 栈内存/堆内存 当前源文件定义处的作用域内 当前源文件定义处的作用域内，作用域执行完则销毁 5.2. 面向对象设计中的static 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); static void GetSum(); // 声明静态成员函数private: int a,b,c; static int Sum; // 声明静态数据成员&#125;;int Myclass::Sum=0; // 定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c; // 非静态成员函数可以访问静态数据成员&#125;void Myclass::GetSum() // 静态成员函数的实现&#123; // cout&lt;&lt;a&lt;&lt;endl; // 错误代码，a是非静态数据成员 cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl;&#125;void main()&#123; Myclass M(1,2,3); M.GetSum(); Myclass N(4,5,6); N.GetSum(); M.GetSum();&#125; 静态数据成员 静态数据成员数据存储在静态存储区，静态数据成员定义时要分配空间，所以类的声明中只能进行静态数据成员的声明，其定义和初始化必须在类声明外执行 静态数据成员只分配一次内存空间，因此该类的所以实例或子类实例，对该静态数据成员的引用均指向同一地址，一处修改，对于全部引用生效 静态数据成员不用对类进行实例化也可访问,但是跟普通数据成员一样，遵从public,protected,private访问规则 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： ＜数据类型＞ ＜类名＞::＜静态数据成员名＞ = ＜值＞ 类的静态数据成员有两种访问形式：普通数据成员访问方式(＜类实例名＞.＜静态数据成员名＞)或静态数据成员特有访问方式(＜类类型名＞::＜静态数据成员名＞) 静态成员函数 类声明外的函数不能指定关键字static 类的静态成员函数有两种访问形式：普通成员函数访问方式(＜类实例名＞.＜静态成员函数名＞(＜参数表＞))或静态成员函数特有访问方式(＜类类型名＞::＜静态成员函数名＞(＜参数表＞)) 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数，非静态成员函数可以任意地访问静态成员函数和静态数据成员，但静态成员函数不能访问非静态成员函数和非静态数据成员 静态成员函数在内存中只拷贝一份，而普通函数在每次调用是都会拷贝一次 5.3. const const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 5.3.1. const修饰成员变量 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int a1=3; //non-const data const int a2=a1; //const data int * a3 = &amp;a1; //non-const data,non-const pointer const int * a4 = &amp;a1; //const data,non-const pointer int * const a5 = &amp;a1; //non-const data,const pointer int const * const a6 = &amp;a1; //const data,const pointer const int * const a7 = &amp;a1; //const data,const pointer return 0;&#125; const修饰指针变量时： 只有一个const，如果const位于*左侧，表示指针所指数据是常量，不能通过解引用修改该数据；指针本身是变量，可以指向其他的内存单元。 只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存地址；指针所指的数据可以通过解引用修改。 两个const，*左右各一个，表示指针和指针所指数据都不能修改。 5.3.2. const修饰函数参数 传递过来的参数在函数内不可以改变，与上面修饰变量时的性质一样。 123void testModifyConst(const int _x) &#123; _x=5; //编译出错&#125; 5.3.3. const修饰成员函数 const修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外) const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Point&#123; public : Point(int _x):x(_x)&#123;&#125; void testConstFunction(int _x) const&#123; //错误，在const成员函数中，不能修改任何类成员变量 x=_x; //错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 modify_x(_x); &#125; void modify_x(int _x)&#123; x=_x; &#125; int x;&#125;; 5.3.4. const修饰函数返回值 指针传递 如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据是常量不能修改。 1234567891011const int * mallocA()&#123; //const data,non-const pointer int *a=new int(2); return a;&#125;int main()&#123; const int *a = mallocA(); //int *b = mallocA(); ///编译错误 return 0;&#125; 值传递 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。 所以： 不要把函数int GetInt(void) 写成const int GetInt(void) 不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。 5.4. volatile 5.4.1. volatile的作用 volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 123456789101112131415#include &lt;stdio.h&gt;void main()&#123; int i = 10; int a = i; printf(&quot;i = %d&quot;, a); // 下面汇编语句的作用就是改变内存中 i 的值 // 但是又不让编译器知道 __asm &#123; mov dword ptr [ebp-4], 20h &#125; int b = i; printf(&quot;i = %d&quot;, b);&#125; 然后，在 Debug 版本模式运行程序，输出结果如下： i = 10 i = 32 在 Release 版本模式运行程序，输出结果如下： i = 10 i = 10 输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。把 i 的声明加上 volatile 关键字，在 Debug 和 Release 版本运行程序，输出为： i = 10 i = 10 其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方： 中断服务程序中修改的供其它程序检测的变量需要加volatile 多任务环境下各任务间共享的标志应该加volatile 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义 5.4.2. volatile指针 和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念： 修饰由指针指向的对象、数据是 const 或 volatile 的： 12const char* cpch;volatile char* vpch; 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的： 12char* const pchc;char* volatile pchv; 注意： 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰 C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员 5.5. 多线程下的volatile 有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下： volatile BOOL bStop = FALSE; (1) 在一个线程中： 123while( !bStop ) &#123; ... &#125;bStop = FALSE;return; (2) 在另外一个线程中，要终止上面的线程循环： 12bStop = TRUE;while( bStop ); //等待上面的线程终止，如果bStop不使用volatile申明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。 6. C和C++相互调用 6.1. C++中调用C 6.2. C中调用C++ 7. 参考文献 [1] C/C++文字常量与常变量","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/tags/C-C/"},{"name":"高级特性","slug":"高级特性","permalink":"https://cyriltaylor.github.io/tags/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"Linux设备树","slug":"Linux/Linux设备树","date":"2019-10-09T07:01:43.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3787073306/","link":"","permalink":"https://cyriltaylor.github.io/posts/3787073306/","excerpt":"1. 设备树基础 1.1. 设备树的引入 1.2. 设备树特点 1.3. 编译设备树 1.3. 编译设备树 2. 设备树dts/dtsi格式 3. 设备树dtb格式和结构 4. 内核head.S对uboot传参的处理 5. 设备树对平台信息的处理machine_desc 6. 设备树对运行时配置信息的处理 7. dtb到设备节点的转换 8. 设备节点到平台设备的转换 9. platform_device和platform_driver如何让匹配 10. 在根文件系统中查看设备树 11. 内核中设备树的操作函数 12. uboot如何给内核传dtb文件 13. 有了设备树后新内核对于设备处理的不同之处 14. aliases节点分析 15. 引入设备树对中断的影响 16. 番外篇-中断子系统之IRQ Domain介绍 17. 番外篇-中断子系统之IRQ number和中断描述符 18. 番外篇-中断子系统之内核对中断控制器的解析 19. 番外篇-中断子系统之初始化一个中断控制器 20. 番外篇-中断子系统之中断号的映射与反映射[一] 21. 番外篇-中断子系统之中断号的映射与反映射[二] 22. 番外篇-中断子系统之简单举例使用 23. 番外篇-中断子系统之驱动申请API 24. 番外篇-中断子系统之softirq 25. 番外篇-中断子系统之tasklet 26. 番外篇-中断子系统之workqueue[1] 27. 番外篇-中断子系统之CMWQ概述[2] 28. 番外篇-中断子系统之workqueue创建[3] 29. 番外篇-中断子系统之workqueue处理work[4] 30. 番外篇-中断子系统之workqueue使用","text":"1. 设备树基础 1.1. 设备树的引入 1.2. 设备树特点 1.3. 编译设备树 1.3. 编译设备树 2. 设备树dts/dtsi格式 3. 设备树dtb格式和结构 4. 内核head.S对uboot传参的处理 5. 设备树对平台信息的处理machine_desc 6. 设备树对运行时配置信息的处理 7. dtb到设备节点的转换 8. 设备节点到平台设备的转换 9. platform_device和platform_driver如何让匹配 10. 在根文件系统中查看设备树 11. 内核中设备树的操作函数 12. uboot如何给内核传dtb文件 13. 有了设备树后新内核对于设备处理的不同之处 14. aliases节点分析 15. 引入设备树对中断的影响 16. 番外篇-中断子系统之IRQ Domain介绍 17. 番外篇-中断子系统之IRQ number和中断描述符 18. 番外篇-中断子系统之内核对中断控制器的解析 19. 番外篇-中断子系统之初始化一个中断控制器 20. 番外篇-中断子系统之中断号的映射与反映射[一] 21. 番外篇-中断子系统之中断号的映射与反映射[二] 22. 番外篇-中断子系统之简单举例使用 23. 番外篇-中断子系统之驱动申请API 24. 番外篇-中断子系统之softirq 25. 番外篇-中断子系统之tasklet 26. 番外篇-中断子系统之workqueue[1] 27. 番外篇-中断子系统之CMWQ概述[2] 28. 番外篇-中断子系统之workqueue创建[3] 29. 番外篇-中断子系统之workqueue处理work[4] 30. 番外篇-中断子系统之workqueue使用 1. 设备树基础 1.1. 设备树的引入 Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，ARM Linux社区对此作出了回应，引入设备树。 ARM Device Tree起源于OpenFirmware (OF)，在过去的Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。为了改变这种局面，Linux社区的大牛们参考了PowerPC等体系架构中使用的Flattened Device Tree（FDT），也采用了Device Tree结构，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。 Device Tree是一种描述硬件的数据结构，它起源于 OpenFirmware (OF)。在Linux 2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。 Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）： CPU的数量和类别 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况 Clock控制器和Clock使用情况 这种以树状节点的方式描述一个设备的各种硬件信息：CPU、GPIO、时钟、中断、内存等，形成类似文本文件，很好的解决了这些问题。 它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备，而这些设备用到的内存、IRQ等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。 通常由.dts文件以文本方式对系统设备树进行描述，经过Device Tree Compiler(dtc)将dts文件转换成二进制文件binary device tree blob(dtb)，.dtb文件可由Linux内核解析，有了device tree就可以在不改动Linux内核的情况下，对不同的平台实现无差异的支持，只需更换相应的dts文件，即可满足。 1.2. 设备树特点 对于传统字符驱动的编写有两种方式： 一是在驱动程序中，直接写死硬件资源，如：GPIO、寄存器地址、中断号等，使得硬件改动时，必须修改驱动程序。 二是采用总线驱动platform模型，将硬件资源与驱动软件分离，在platform_device中描述硬件资源，arch/arm/mach-xxx对应的文件，便是以platform_device描述各自CPU对应的硬件资源；在platform_driver中分配/设置/注册 file_operations结构体, 并从platform_device获得硬件资源。这种编写方式使得驱动易于扩展，硬件改动时只需修改platform_device或者platform_driver，这就导致linux内核产生大量的冗余代码。 使用设备树的特点在于，在设备树dts文件指定硬件资源，dts被编译为dtb文件, 在启动单板时，U-boot会将dtb文件传给内核，使得驱动程序与硬件分离，我们只需要修改dts文件，便能实现需求。这就是设备树易于扩展，硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的dtb文件。 1.3. 编译设备树 设备树文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图所示。 dtc工具的使用方法是：dtc –I dts –O dtb –o xxx.dtb xxx.dts，即可生成dts文件对应的dtb文件了。 在编译linux内核时。也可以直接make dtbs生成dtb文件。 1.3. 编译设备树 2. 设备树dts/dtsi格式 3. 设备树dtb格式和结构 4. 内核head.S对uboot传参的处理 5. 设备树对平台信息的处理machine_desc 6. 设备树对运行时配置信息的处理 7. dtb到设备节点的转换 8. 设备节点到平台设备的转换 9. platform_device和platform_driver如何让匹配 10. 在根文件系统中查看设备树 11. 内核中设备树的操作函数 内核中开放出来的接口函数的声明大多在include/linux/下面，关于设备树的都是以ofxxx.h形式命名 12345678910111213141516171819202122232425262728/*--- 处理dtb文件 ---*/include/linux/of_fdt.h // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)/*--- 处理device_node ---*/include/linux/of_address.h // 地址相关的函数, 如 // of_get_address(获得reg属性中的addr, size值)include/linux/of_clk.hinclude/linux/of_dma.h // 设备树中DMA相关属性的函数include/linux/of_gpio.h // GPIO相关的函数include/linux/of_graph.h // GPU相关驱动中用到的函数, 从设备树中获得GPU信息include/linux/of.h // 提供设备树的一般处理函数, 如 // of_property_read_u32(读取某个属性的u32值) // of_get_child_count(获取某个device_node的子节点数)include/linux/of_iommu.hinclude/linux/of_irq.h // 中断相关的函数include/linux/of_mdio.h // MDIO (Ethernet PHY) APIinclude/linux/of_net.h // OF helpers for network devices.include/linux/of_pci.h // PCI相关函数include/linux/of_pdt.hinclude/linux/of_reserved_mem.h // reserved_mem的相关函数/*--- 处理 platform_device ---*/include/linux/of_device.h // 设备相关的函数，如 // of_match_device(从matches数组中取出与当前设备最匹配的一项)include/linux/of_platform.h // 把device_node转换为platform_device时用到的函数，如 // of_device_alloc(根据device_node分配设置platform_device) // of_find_device_by_node(根据device_node查找到platform_device) // of_platform_bus_probe(处理device_node及它的子节点) 以of_fdt.h 头文件中举几个例子 1234567891011121314151617181920//blob也就是启动时保留的那块存放dtb文件内存的起始地址,下面分别是从dtb文件中扫描获取信息/* For scanning an arbitrary device-tree at any time */extern char *of_fdt_get_string(const void *blob, u32 offset); // 从起始地址+偏移获取字符串extern void *of_fdt_get_property(const void *blob, // 通过起始地址 unsigned long node, const char *name, int *size);extern bool of_fdt_is_big_endian(const void *blob, // 判断某个节点是不是大端存放的 unsigned long node);extern int of_fdt_match(const void *blob, unsigned long node, // 判断节点是不是匹配的 const char *const *compat);extern void *of_fdt_unflatten_tree(const unsigned long *blob, // 解析dtb到device_node的函数 struct device_node *dad, struct device_node **mynodes);/* TBD: Temporary export of fdt globals - remove when code fully merged */extern int __initdata dt_root_addr_cells; // 内核dtb文件的根节点中addr-cells的值extern int __initdata dt_root_size_cells; // 内核dtb文件的根节点中size-cells的值extern void *initial_boot_params; // 内核存放dtb文件的地址(虚拟地址) 当然我们更多的是通过of.h文件中获取一个节点或者节点的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 下面是在from节点下面,通过name,type或者compatible属性获取具有相同名字或类型的节点extern struct device_node *of_find_node_by_name(struct device_node *from, const char *name);extern struct device_node *of_find_node_by_type(struct device_node *from, const char *type);extern struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compat);// 当然这里也可以通过一个设备节点,获取里面某个属性的值static inline int of_property_read_u8(const struct device_node *np, const char *propname, u8 *out_value)&#123; return of_property_read_u8_array(np, propname, out_value, 1);&#125;static inline int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value)&#123; return of_property_read_u16_array(np, propname, out_value, 1);&#125;static inline int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)&#123; return of_property_read_u32_array(np, propname, out_value, 1);&#125;static inline int of_property_read_s32(const struct device_node *np, const char *propname, s32 *out_value)&#123; return of_property_read_u32(np, propname, (u32*) out_value);&#125;// 获取某个节点字符串数量static inline int of_property_count_strings(const struct device_node *np, const char *propname)&#123; return of_property_read_string_helper(np, propname, NULL, 0, 0);&#125;// 获取某个界定里的字符串数字static inline int of_property_read_string_array(const struct device_node *np, const char *propname, const char **out_strs, size_t sz)&#123; return of_property_read_string_helper(np, propname, out_strs, sz, 0);&#125;// 同时也可以获取到字符串数组的某个指定的字符串static inline int of_property_read_string_index(const struct device_node *np, const char *propname, int index, const char **output)&#123; int rc = of_property_read_string_helper(np, propname, output, 1, index); return rc &lt; 0 ? rc : 0;&#125; 基本上我们想到的获取设备树中那种信息，都会有相应的函数接口。我们只需要调用就可以了。 12. uboot如何给内核传dtb文件 13. 有了设备树后新内核对于设备处理的不同之处 14. aliases节点分析 15. 引入设备树对中断的影响 16. 番外篇-中断子系统之IRQ Domain介绍 17. 番外篇-中断子系统之IRQ number和中断描述符 18. 番外篇-中断子系统之内核对中断控制器的解析 19. 番外篇-中断子系统之初始化一个中断控制器 20. 番外篇-中断子系统之中断号的映射与反映射[一] 21. 番外篇-中断子系统之中断号的映射与反映射[二] 22. 番外篇-中断子系统之简单举例使用 23. 番外篇-中断子系统之驱动申请API 24. 番外篇-中断子系统之softirq 25. 番外篇-中断子系统之tasklet 26. 番外篇-中断子系统之workqueue[1] 27. 番外篇-中断子系统之CMWQ概述[2] 28. 番外篇-中断子系统之workqueue创建[3] 29. 番外篇-中断子系统之workqueue处理work[4] 30. 番外篇-中断子系统之workqueue使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/tags/Linux/"},{"name":"设备树","slug":"设备树","permalink":"https://cyriltaylor.github.io/tags/%E8%AE%BE%E5%A4%87%E6%A0%91/"}],"author":[{"name":"to_run_away","homepage":"https://blog.csdn.net/qq_16777851","photo":"qq_16777851.jpg"}]},{"title":"C++编程规范","slug":"C++/C++编程规范","date":"2019-10-08T09:51:15.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3424946910/","link":"","permalink":"https://cyriltaylor.github.io/posts/3424946910/","excerpt":"1. 常用单词缩写","text":"1. 常用单词缩写 1. 常用单词缩写 单词 缩写 解释 addition add 加 answer ans 响应、回答 array arr 数组、集合 average avg 平均 buffer buf / buff 缓冲区 capture cap / capt 捕获 check chk 检查 column col 列 control ctrl 控制 count cnt 计数器 decode dec 解码、译码 define def 定义 delete del 删除 destination dst / dest 目的 display disp 显示 division div 除法 encode enc 编码 environment env 环境 error err 错误 float flt 浮动、浮点 frequency freq 频率 header hdr 开始、开头 image img 影像、镜像 increment inc 增加、增量 index idx 索引、指示、 initalize init 初始化 iteration itr 循环、迭代 length len 长度 make mk 制造、形成 memory mem 内存 message msg 消息 middle mid 中值 multiplication mul 乘法 number num 数量、编号 operand opnd 操作数 operator optr 操作 optimization opt 最优 packet pkt 消息包 pointer ptr 指针 positon pos 位置 previous pre / prev 以前的 receive recv 收到、接收 record rcd 记录 result res 结果 return ret 返回 source src 源头 stack stk 栈 string str 字符串 subtraction sub 减 table tab 表 temporary tmp / temp 临时 timestamp ts 时间戳 total tot 全部的 value val 值","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/tags/C-C/"},{"name":"编程规范","slug":"编程规范","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"}],"author":[{"name":null,"homepage":null,"photo":null}]},{"title":"斯坦福大学2014(吴恩达)机器学习教程中文笔记","slug":"MachineLearning/斯坦福大学2014（吴恩达）机器学习教程中文笔记","date":"2019-10-07T01:20:01.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/441574646/","link":"","permalink":"https://cyriltaylor.github.io/posts/441574646/","excerpt":"1. 引言(Introduction) 1.1. 欢迎 1.2. 机器学习是什么？ 1.3. 监督学习 1.4. 无监督学习 2. 单变量线性回归**(Linear Regression with One Variable**) 2.1. 模型表示 2.2. 代价函数 2.3. 代价函数的直观理解I 2.4. 代价函数的直观理解II 2.5. 梯度下降 2.6. 梯度下降的直观理解 2.7. 梯度下降的线性回归 2.8. 接下来的内容 3. 线性代数回顾(Linear Algebra Review) 3.1. 矩阵和向量 3.2. 加法和标量乘法 3.3. 矩阵向量乘法 3.4. 矩阵乘法 3.5. 矩阵乘法的性质 3.6. 逆、转置 4. 多变量线性回归(Linear Regression with Multiple Variables) 4.1. 多维特征 4.2. 多变量梯度下降 4.3. 梯度下降法实践1-特征缩放 4.4. 梯度下降法实践2-学习率 4.5. 特征和多项式回归 4.6. 正规方程 4.7. 正规方程及不可逆性（选修） 5. Octave教程(Octave Tutorial) 5.1. 基本操作 5.2. 移动数据 5.3. 计算数据 5.4. 绘图数据 5.5. 控制语句：for，while，if语句 5.6. 向量化 88 5.7. 工作和提交的编程练习 6. 逻辑回归(Logistic Regression) 6.1. 分类问题 6.2. 假说表示 6.3. 判定边界 6.4. 代价函数 6.5. 简化的成本函数和梯度下降 6.6. 高级优化 6.7. 多类别分类：一对多 7. 正则化(Regularization) 7.1. 过拟合的问题 7.2. 代价函数 7.3. 正则化线性回归 7.4. 正则化的逻辑回归模型 8. 神经网络：表述(Neural Networks: Representation) 8.1. 非线性假设 8.2. 神经元和大脑 8.3. 模型表示1 8.4. 模型表示2 8.5. 样本和直观理解1 8.6. 样本和直观理解II 8.7. 多类分类 9. 神经网络的学习(Neural Networks: Learning) 9.1. 代价函数 9.2. 反向传播算法 9.3. 反向传播算法的直观理解 9.4. 实现注意：展开参数 9.5. 梯度检验 9.6. 随机初始化 9.7. 综合起来 9.8. 自主驾驶 10. 应用机器学习的建议(Advice for Applying Machine Learning) 10.1. 决定下一步做什么 10.2. 评估一个假设 10.3. 模型选择和交叉验证集 10.4. 诊断偏差和方差 10.5. 正则化和偏差/方差 10.6. 学习曲线 10.7. 决定下一步做什么 11. 机器学习系统的设计(Machine Learning System Design) 11.1. 首先要做什么 11.2. 误差分析 11.3. 类偏斜的误差度量 11.4. 查准率和查全率之间的权衡 11.5. 机器学习的数据 12. 支持向量机(Support Vector Machines) 12.1. 优化目标 12.2. 大边界的直观理解 12.3. 大边界分类背后的数学（选修） 12.4. 核函数1 12.5. 核函数2 12.6. 使用支持向量机 13. 聚类(Clustering) 13.1. 无监督学习：简介 13.2. K-均值算法 13.3. 优化目标 13.4. 随机初始化 13.5. 选择聚类数 14. 降维(Dimensionality Reduction) 14.1. 动机一：数据压缩 14.2. 动机二：数据可视化 14.3. 主成分分析问题 14.4. 主成分分析算法 14.5. 选择主成分的数量 14.6. 重建的压缩表示 14.7. 主成分分析法的应用建议 15. 异常检测(Anomaly Detection) 15.1. 问题的动机 15.2. 高斯分布 15.3. 算法 15.4. 开发和评价一个异常检测系统 15.5. 异常检测与监督学习对比 15.6. 选择特征 15.7. 多元高斯分布（选修） 15.8. 使用多元高斯分布进行异常检测（选修） 16. 推荐系统(Recommender Systems) 16.1. 问题形式化 16.2. 基于内容的推荐系统 16.3. 协同过滤 16.4. 协同过滤算法 16.5. 向量化：低秩矩阵分解 16.6. 推行工作上的细节：均值归一化 17. 大规模机器学习(Large Scale Machine Learning) 17.1. 大型数据集的学习 17.2. 随机梯度下降法 17.3. 小批量梯度下降 17.4. 随机梯度下降收敛 17.5. 在线学习 17.6. 映射化简和数据并行 18. 应用实例：图片文字识别(Application Example: Photo OCR) 18.1. 问题描述和流程图 18.2. 滑动窗口 18.3. 获取大量数据和人工数据 18.4. 上限分析：哪部分管道的接下去做 19. 总结(Conclusion) 19.1. 总结和致谢","text":"1. 引言(Introduction) 1.1. 欢迎 1.2. 机器学习是什么？ 1.3. 监督学习 1.4. 无监督学习 2. 单变量线性回归**(Linear Regression with One Variable**) 2.1. 模型表示 2.2. 代价函数 2.3. 代价函数的直观理解I 2.4. 代价函数的直观理解II 2.5. 梯度下降 2.6. 梯度下降的直观理解 2.7. 梯度下降的线性回归 2.8. 接下来的内容 3. 线性代数回顾(Linear Algebra Review) 3.1. 矩阵和向量 3.2. 加法和标量乘法 3.3. 矩阵向量乘法 3.4. 矩阵乘法 3.5. 矩阵乘法的性质 3.6. 逆、转置 4. 多变量线性回归(Linear Regression with Multiple Variables) 4.1. 多维特征 4.2. 多变量梯度下降 4.3. 梯度下降法实践1-特征缩放 4.4. 梯度下降法实践2-学习率 4.5. 特征和多项式回归 4.6. 正规方程 4.7. 正规方程及不可逆性（选修） 5. Octave教程(Octave Tutorial) 5.1. 基本操作 5.2. 移动数据 5.3. 计算数据 5.4. 绘图数据 5.5. 控制语句：for，while，if语句 5.6. 向量化 88 5.7. 工作和提交的编程练习 6. 逻辑回归(Logistic Regression) 6.1. 分类问题 6.2. 假说表示 6.3. 判定边界 6.4. 代价函数 6.5. 简化的成本函数和梯度下降 6.6. 高级优化 6.7. 多类别分类：一对多 7. 正则化(Regularization) 7.1. 过拟合的问题 7.2. 代价函数 7.3. 正则化线性回归 7.4. 正则化的逻辑回归模型 8. 神经网络：表述(Neural Networks: Representation) 8.1. 非线性假设 8.2. 神经元和大脑 8.3. 模型表示1 8.4. 模型表示2 8.5. 样本和直观理解1 8.6. 样本和直观理解II 8.7. 多类分类 9. 神经网络的学习(Neural Networks: Learning) 9.1. 代价函数 9.2. 反向传播算法 9.3. 反向传播算法的直观理解 9.4. 实现注意：展开参数 9.5. 梯度检验 9.6. 随机初始化 9.7. 综合起来 9.8. 自主驾驶 10. 应用机器学习的建议(Advice for Applying Machine Learning) 10.1. 决定下一步做什么 10.2. 评估一个假设 10.3. 模型选择和交叉验证集 10.4. 诊断偏差和方差 10.5. 正则化和偏差/方差 10.6. 学习曲线 10.7. 决定下一步做什么 11. 机器学习系统的设计(Machine Learning System Design) 11.1. 首先要做什么 11.2. 误差分析 11.3. 类偏斜的误差度量 11.4. 查准率和查全率之间的权衡 11.5. 机器学习的数据 12. 支持向量机(Support Vector Machines) 12.1. 优化目标 12.2. 大边界的直观理解 12.3. 大边界分类背后的数学（选修） 12.4. 核函数1 12.5. 核函数2 12.6. 使用支持向量机 13. 聚类(Clustering) 13.1. 无监督学习：简介 13.2. K-均值算法 13.3. 优化目标 13.4. 随机初始化 13.5. 选择聚类数 14. 降维(Dimensionality Reduction) 14.1. 动机一：数据压缩 14.2. 动机二：数据可视化 14.3. 主成分分析问题 14.4. 主成分分析算法 14.5. 选择主成分的数量 14.6. 重建的压缩表示 14.7. 主成分分析法的应用建议 15. 异常检测(Anomaly Detection) 15.1. 问题的动机 15.2. 高斯分布 15.3. 算法 15.4. 开发和评价一个异常检测系统 15.5. 异常检测与监督学习对比 15.6. 选择特征 15.7. 多元高斯分布（选修） 15.8. 使用多元高斯分布进行异常检测（选修） 16. 推荐系统(Recommender Systems) 16.1. 问题形式化 16.2. 基于内容的推荐系统 16.3. 协同过滤 16.4. 协同过滤算法 16.5. 向量化：低秩矩阵分解 16.6. 推行工作上的细节：均值归一化 17. 大规模机器学习(Large Scale Machine Learning) 17.1. 大型数据集的学习 17.2. 随机梯度下降法 17.3. 小批量梯度下降 17.4. 随机梯度下降收敛 17.5. 在线学习 17.6. 映射化简和数据并行 18. 应用实例：图片文字识别(Application Example: Photo OCR) 18.1. 问题描述和流程图 18.2. 滑动窗口 18.3. 获取大量数据和人工数据 18.4. 上限分析：哪部分管道的接下去做 19. 总结(Conclusion) 19.1. 总结和致谢 1. 引言(Introduction) 1.1. 欢迎 1.2. 机器学习是什么？ 1.3. 监督学习 1.4. 无监督学习 2. 单变量线性回归**(Linear Regression with One Variable**) 2.1. 模型表示 2.2. 代价函数 2.3. 代价函数的直观理解I 2.4. 代价函数的直观理解II 2.5. 梯度下降 2.6. 梯度下降的直观理解 2.7. 梯度下降的线性回归 2.8. 接下来的内容 3. 线性代数回顾(Linear Algebra Review) 3.1. 矩阵和向量 3.2. 加法和标量乘法 3.3. 矩阵向量乘法 3.4. 矩阵乘法 3.5. 矩阵乘法的性质 3.6. 逆、转置 4. 多变量线性回归(Linear Regression with Multiple Variables) 4.1. 多维特征 4.2. 多变量梯度下降 4.3. 梯度下降法实践1-特征缩放 4.4. 梯度下降法实践2-学习率 4.5. 特征和多项式回归 4.6. 正规方程 4.7. 正规方程及不可逆性（选修） 5. Octave教程(Octave Tutorial) 5.1. 基本操作 5.2. 移动数据 5.3. 计算数据 5.4. 绘图数据 5.5. 控制语句：for，while，if语句 5.6. 向量化 88 5.7. 工作和提交的编程练习 6. 逻辑回归(Logistic Regression) 6.1. 分类问题 6.2. 假说表示 6.3. 判定边界 6.4. 代价函数 6.5. 简化的成本函数和梯度下降 6.6. 高级优化 6.7. 多类别分类：一对多 7. 正则化(Regularization) 7.1. 过拟合的问题 7.2. 代价函数 7.3. 正则化线性回归 7.4. 正则化的逻辑回归模型 8. 神经网络：表述(Neural Networks: Representation) 8.1. 非线性假设 8.2. 神经元和大脑 8.3. 模型表示1 8.4. 模型表示2 8.5. 样本和直观理解1 8.6. 样本和直观理解II 8.7. 多类分类 9. 神经网络的学习(Neural Networks: Learning) 9.1. 代价函数 9.2. 反向传播算法 9.3. 反向传播算法的直观理解 9.4. 实现注意：展开参数 9.5. 梯度检验 9.6. 随机初始化 9.7. 综合起来 9.8. 自主驾驶 10. 应用机器学习的建议(Advice for Applying Machine Learning) 10.1. 决定下一步做什么 10.2. 评估一个假设 10.3. 模型选择和交叉验证集 10.4. 诊断偏差和方差 10.5. 正则化和偏差/方差 10.6. 学习曲线 10.7. 决定下一步做什么 11. 机器学习系统的设计(Machine Learning System Design) 11.1. 首先要做什么 11.2. 误差分析 11.3. 类偏斜的误差度量 11.4. 查准率和查全率之间的权衡 11.5. 机器学习的数据 12. 支持向量机(Support Vector Machines) 12.1. 优化目标 12.2. 大边界的直观理解 12.3. 大边界分类背后的数学（选修） 12.4. 核函数1 12.5. 核函数2 12.6. 使用支持向量机 13. 聚类(Clustering) 13.1. 无监督学习：简介 13.2. K-均值算法 13.3. 优化目标 13.4. 随机初始化 13.5. 选择聚类数 14. 降维(Dimensionality Reduction) 14.1. 动机一：数据压缩 14.2. 动机二：数据可视化 14.3. 主成分分析问题 14.4. 主成分分析算法 14.5. 选择主成分的数量 14.6. 重建的压缩表示 14.7. 主成分分析法的应用建议 15. 异常检测(Anomaly Detection) 15.1. 问题的动机 15.2. 高斯分布 15.3. 算法 15.4. 开发和评价一个异常检测系统 15.5. 异常检测与监督学习对比 15.6. 选择特征 15.7. 多元高斯分布（选修） 15.8. 使用多元高斯分布进行异常检测（选修） 16. 推荐系统(Recommender Systems) 16.1. 问题形式化 16.2. 基于内容的推荐系统 16.3. 协同过滤 16.4. 协同过滤算法 16.5. 向量化：低秩矩阵分解 16.6. 推行工作上的细节：均值归一化 17. 大规模机器学习(Large Scale Machine Learning) 17.1. 大型数据集的学习 17.2. 随机梯度下降法 17.3. 小批量梯度下降 17.4. 随机梯度下降收敛 17.5. 在线学习 17.6. 映射化简和数据并行 18. 应用实例：图片文字识别(Application Example: Photo OCR) 18.1. 问题描述和流程图 18.2. 滑动窗口 18.3. 获取大量数据和人工数据 18.4. 上限分析：哪部分管道的接下去做 19. 总结(Conclusion) 19.1. 总结和致谢","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://cyriltaylor.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://cyriltaylor.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://cyriltaylor.github.io/tags/Python/"}]},{"title":"Flutter基础教程","slug":"Flutter/Flutter基础教程","date":"2019-10-05T17:07:25.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/777259726/","link":"","permalink":"https://cyriltaylor.github.io/posts/777259726/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"开源项目推荐","slug":"Tools/开源项目推荐","date":"2019-10-05T13:21:59.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1940182387/","link":"","permalink":"https://cyriltaylor.github.io/posts/1940182387/","excerpt":"1. Flutter 1.1. 电子书《Flutter实战》 Python Python - 100天从新手到大师 机器学习 机器学习100天 Tools Flight rules for Git","text":"1. Flutter 1.1. 电子书《Flutter实战》 Python Python - 100天从新手到大师 机器学习 机器学习100天 Tools Flight rules for Git 1. Flutter 1.1. 电子书《Flutter实战》 电子书web版本：《Flutter实战》 电子书开源项目：flutter-in-action Python Python - 100天从新手到大师 Python-100-Days，一个从入门到精通百日教程，包含Python基础/进阶教程，爬虫、Django、机器学习等 机器学习 机器学习100天 机器学习100天，一个非常详尽的100天学习机器学习的项目 Tools Flight rules for Git Flight rules for Git，项目里面罗列了git在实用的过程中出现的常见问题时的标准处理方案，对于git操作不熟悉的用户来说是非常有用的。","categories":[],"tags":[]},{"title":"Visual Studio Code配置","slug":"Tools/VSCode配置","date":"2019-10-05T13:21:59.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1940182388/","link":"","permalink":"https://cyriltaylor.github.io/posts/1940182388/","excerpt":"推荐插件","text":"推荐插件 推荐插件 插件列表 插件 安装量 描述 SQLite 测试 alanwalk.markdown-toc 测试 alefragnani.bookmarks 测试 一键安装脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!env python# -*- Coding: utf-8 -*-from os import getcwd, altsepfrom subprocess import Popen, PIPE, STDOUT, TimeoutExpiredfrom func_timeout import func_timeout, FunctionTimedOutdef main(): tupleExtension = ( &#x27;alanwalk.markdown-toc&#x27;, &#x27;alefragnani.bookmarks&#x27;, &#x27;alexcvzz.vscode-sqlite&#x27;, &#x27;anseki.vscode-color&#x27;, &#x27;austin.code-gnu-global&#x27;, &#x27;bierner.markdown-preview-github-styles&#x27;, &#x27;christian-kohler.npm-intellisense&#x27;, &#x27;coenraads.bracket-pair-colorizer&#x27;, &#x27;dan-c-underwood.arm&#x27;, &#x27;dart-code.dart-code&#x27;, &#x27;dart-code.flutter&#x27;, &#x27;davidanson.vscode-markdownlint&#x27;, &#x27;donjayamanne.githistory&#x27;, &#x27;dotjoshjohnson.xml&#x27;, &#x27;eamodio.gitlens&#x27;, &#x27;eg2.vscode-npm-script&#x27;, &#x27;equinusocio.vsc-material-theme&#x27;, &#x27;esbenp.prettier-vscode&#x27;, &#x27;gruntfuggly.todo-tree&#x27;, &#x27;hookyqr.beautify&#x27;, &#x27;jerryhong.autofilename&#x27;, &#x27;jock.svg&#x27;, &#x27;k--kato.intellij-idea-keybindings&#x27;, &#x27;mathiasfrohlich.kotlin&#x27;, &#x27;michalyao.evermonkey&#x27;, &#x27;ms-mssql.mssql&#x27;, &#x27;ms-python.python&#x27;, &#x27;ms-vscode-remote.remote-ssh&#x27;, &#x27;ms-vscode-remote.remote-ssh-edit&#x27;, &#x27;ms-vscode-remote.remote-ssh-explorer&#x27;, &#x27;ms-vscode-remote.remote-wsl&#x27;, &#x27;ms-vscode.cpptools&#x27;, &#x27;ms-vscode.powershell&#x27;, &#x27;naumovs.color-highlight&#x27;, &#x27;oderwat.indent-rainbow&#x27;, &#x27;pkief.material-icon-theme&#x27;, &#x27;rsbondi.highlight-words&#x27;, &#x27;ryannaddy.vscode-format&#x27;, &#x27;shan.code-settings-sync&#x27;, &#x27;slevesque.vscode-hexdump&#x27;, &#x27;tabnine.tabnine-vscode&#x27;, &#x27;tushortz.python-extended-snippets&#x27;, &#x27;yzhang.markdown-all-in-one&#x27;, &#x27;zhoufeng.pyqt-integration&#x27;, ) curdir = getcwd() index = 1 total = len(tupleExtension) for extension in tupleExtension: while True: print(&quot;[&quot; + str(index) + &quot;/&quot; + str(total) + &quot;] &quot; + curdir + altsep + &quot;bin&quot; + altsep + &quot;code --install-extension &quot; + extension + &quot; --force&quot;) proc = Popen(curdir + altsep + &quot;bin&quot; + altsep + &quot;code --install-extension &quot; + extension + &quot; --force&quot;, shell=True, stdout=PIPE, stderr=STDOUT, encoding=&quot;utf8&quot;) try: outs, errs = proc.communicate(timeout=60) except TimeoutExpired: proc.kill() if not None == outs: print(outs) if (&#x27;was successfully installed&#x27; in outs) or (&#x27;is already installed&#x27; in outs): index += 1 breakif __name__ == &quot;__main__&quot;: main()","categories":[],"tags":[]},{"title":"zsh详解","slug":"Shell/Shell进阶","date":"2019-09-16T06:14:04.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/1879721729/","link":"","permalink":"https://cyriltaylor.github.io/posts/1879721729/","excerpt":"1. zsh快捷键 2. oh-my-zsh框架配置 3. zsh主题配置","text":"1. zsh快捷键 2. oh-my-zsh框架配置 3. zsh主题配置 1. shell快捷键 https://linuxtoy.org/archives/bash-shortcuts.html 类型 快捷键 功能 编辑命令 Ctrl + a / ⌃ + a 移到命令行首 … Ctrl + e / ⌃ + e 移到命令行尾 … Ctrl + f 按字符前移（右向） … Ctrl + b 按字符后移（左向） … Alt + f 按单词前移（右向） … Alt + b 按单词后移（左向） … Ctrl + xx 在命令行首和光标之间移动 … Ctrl + u 从光标处删除至命令行首 … Ctrl + k 从光标处删除至命令行尾 … Ctrl + w 从光标处删除至字首 … Alt + d 从光标处删除至字尾 … Ctrl + d 删除光标处的字符 … Ctrl + h 删除光标前的字符 … Ctrl + y 粘贴至光标后 … Alt + c 从光标处更改为首字母大写的单词 … Alt + u 从光标处更改为全部大写的单词 … Alt + l 从光标处更改为全部小写的单词 … Ctrl + t 交换光标处和之前的字符 … Alt + t 交换光标处和之前的单词 … Alt + Backspace 从光标处删除至字首 … Ctrl + r 逆向搜索命令历史 … Ctrl + g 从历史搜索模式退出 … Ctrl + p 历史中的上一条命令 … Ctrl + n 历史中的下一条命令 … Alt + . 使用上一条命令的最后一个参数 控制命令 Ctrl + l 清屏 … Ctrl + o 执行当前命令，并选择上一条命令 … Ctrl + s 阻止屏幕输出 … Ctrl + q 允许屏幕输出 … Ctrl + c 终止命令 … Ctrl + z 挂起命令 … Ctrl + n 新建窗口 Bang (!) 命令 !! 执行上一条命令 … !blah 执行最近的以 blah 开头的命令，如 !ls … !blah:p 仅打印输出，而不执行 … !$ 上一条命令的最后一个参数，与 Alt + . 相同 … !$:p 打印输出 !$ 的内容 … !* 上一条命令的所有参数 … !*:p 打印输出 !* 的内容 … ^blah 删除上一条命令中的 blah … ^blah^foo 将上一条命令中的 blah 替换为 foo … ^blah^foo^ 将上一条命令中所有的 blah 都替换为 foo 终端快捷键 Ctrl + n 新建窗口 … Ctrl(⌘) + t 新建标签页 … Ctrl + w 关闭当前标签页 … Ctrl + [num] / Ctrl + [nav] 切换标签页 … Ctrl(⌘) +Alt(⌥) + [num] 切换窗口 ⌘ + enter 切换全屏 ⌘ + d 左右分屏 ⇧⌘ + d 上下分屏 ⌘ + ; 自动补全历史记录 ⇧⌘ + h 自动补全剪贴板历史 ⌥⌘ + e 查找所有来定位某个标签页 ⌘ + r&amp;⌃ + l 清屏 ⌘ + / 显示光标位置 ⌥⌘ + b 历史回放 ⌘ + f 查找，然后用tab和⇧ + tab可以向右和向左补全，补全之后的内容会被自动复制， 还可以用⌥ + enter将查找结果输入终端 2. oh-my-zsh框架配置 详情请参考zsh配置 123456# 安装Oh My ZSH框架sudo apt update &amp;&amp; sudo apt install -y zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;zsh -c &quot;git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/themes/powerlevel10k&quot;zsh -c &quot;git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting&quot;zsh -c &quot;git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions&quot; Home目录下创建.hyrc.zsh文件，并添加如下内容： 1234567891011121314151617181920212223242526272829# git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10kZSH_THEME=powerlevel10k/powerlevel10k# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS=&quot;true&quot;plugins=( git colored-man-pages colorize command-not-found cp compleat sudo # git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh-syntax-highlighting # git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-autosuggestions)# zsh-autosuggestionsZSH_AUTOSUGGEST_STRATEGY=(history completion)# User configurationexport TERM=xterm-256color# Aliasesalias repo=&quot;repo --no-pager&quot; 在.zshrc中将自定义配置添加在source $ZSH/oh-my-zsh.sh之前 12345678910111213141516171819diff --git a/.zshrc b/.zshrcindex 7f58c50..3f8c488 100644--- a/.zshrc+++ b/.zshrc@@ -68,11 +77,27 @@ ZSH_THEME=&quot;robbyrussell&quot; # Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git)+if [[ -f $&#123;HOME&#125;/.hyrc.zsh ]]; then+ source $&#123;HOME&#125;/.hyrc.zsh+fi source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=&quot;/usr/local/man:$MANPATH&quot; 3. zsh主题配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687diff --git a/.p10k.zsh b/.p10k.zshindex 9fb0e29..9d1d905 100644--- a/.p10k.zsh+++ b/.p10k.zsh@@ -38,6 +38,7 @@ vcs # git status # =========================[ Line #2 ]========================= newline+ context prompt_char # prompt symbol )@@ -65,18 +66,19 @@ kubecontext # current kubernetes context (https://kubernetes.io/) terraform # terraform workspace (https://www.terraform.io) aws # aws profile (https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html)- context # user@hostname+ # context # user@hostname nordvpn # nordvpn connection status, linux only (https://nordvpn.com/) ranger # ranger shell (https://github.com/ranger/ranger) # vpn_ip # virtual private network indicator # ram # free RAM # load # CPU load- time # current time+ # time # current time # =========================[ Line #2 ]========================= newline # public_ip # public IP address # proxy # system-wide http/https/ftp proxy # battery # internal battery+ time # current time # example # example user-defined segment (see prompt_example function below) )@@ -301,6 +303,9 @@ # Branch icon. Set this parameter to &#x27;\\uF126 &#x27; for the popular Powerline branch icon. typeset -g POWERLEVEL9K_VCS_BRANCH_ICON=&#x27;\\uF126 &#x27; POWERLEVEL9K_VCS_BRANCH_ICON=$&#123;(g::)POWERLEVEL9K_VCS_BRANCH_ICON&#125;+ typeset -g POWERLEVEL9K_VCS_COMMIT_ICON=&#x27;&#x27;+ # typeset -g POWERLEVEL9K_VCS_REMOTE_BRANCH_ICON=&#x27;&#x27;+ typeset -g POWERLEVEL9K_VCS_TAG_ICON=&#x27;&#x27; # Untracked files icon. It&#x27;s really a question mark, your font isn&#x27;t broken. # Change the value of this parameter to show a different icon.@@ -349,10 +354,10 @@ res+=&quot;$&#123;clean&#125;$&#123;POWERLEVEL9K_VCS_BRANCH_ICON&#125;&quot; where=$&#123;(V)VCS_STATUS_LOCAL_BRANCH&#125; elif [[ -n $VCS_STATUS_TAG ]]; then- res+=&quot;$&#123;meta&#125;#&quot;+ res+=&quot;$&#123;meta&#125;$&#123;(g::)POWERLEVEL9K_VCS_TAG_ICON&#125;&quot; where=$&#123;(V)VCS_STATUS_TAG&#125; else- res+=&quot;$&#123;meta&#125;@&quot;+ res+=&quot;$&#123;meta&#125;$&#123;(g::)POWERLEVEL9K_VCS_COMMIT_ICON&#125;&quot; where=$&#123;VCS_STATUS_COMMIT[1,8]&#125; fi@@ -362,8 +367,8 @@ res+=&quot;$&#123;clean&#125;$&#123;where//\\%/%%&#125;&quot; # escape % # Show tracking branch name if it differs from local branch.- if [[ -n $&#123;VCS_STATUS_REMOTE_BRANCH:#$VCS_STATUS_LOCAL_BRANCH&#125; ]]; then- res+=&quot;$&#123;meta&#125;:$&#123;clean&#125;$&#123;(V)VCS_STATUS_REMOTE_BRANCH//\\%/%%&#125;&quot; # escape %+ if [[ -n $&#123;VCS_STATUS_REMOTE_BRANCH&#125; ]]; then+ res+=&quot;$&#123;meta&#125;--&gt;$&#123;(g::)POWERLEVEL9K_VCS_REMOTE_BRANCH_ICON&#125;$&#123;clean&#125;$&#123;(V)VCS_STATUS_REMOTE_BRANCH//\\%/%%&#125;&quot; # escape % fi # ⇣42 if behind the remote.@@ -436,15 +441,15 @@ # Status when it&#x27;s just an error code (e.g., &#x27;1&#x27;). No need to show it if prompt_char is enabled as # it will signify error by turning red.- typeset -g POWERLEVEL9K_STATUS_ERROR=false+ typeset -g POWERLEVEL9K_STATUS_ERROR=true typeset -g POWERLEVEL9K_STATUS_ERROR_FOREGROUND=160- typeset -g POWERLEVEL9K_STATUS_ERROR_VISUAL_IDENTIFIER_EXPANSION=&#x27;↵&#x27;+ typeset -g POWERLEVEL9K_STATUS_ERROR_VISUAL_IDENTIFIER_EXPANSION=&#x27;✘&#x27; # Status when the last command was terminated by a signal. typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL=true typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL_FOREGROUND=160 # Use terse signal names: &quot;INT&quot; instead of &quot;SIGINT(2)&quot;.- typeset -g POWERLEVEL9K_STATUS_VERBOSE_SIGNAME=false+ typeset -g POWERLEVEL9K_STATUS_VERBOSE_SIGNAME=true typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL_VISUAL_IDENTIFIER_EXPANSION=&#x27;↵&#x27; # Status when some part of a pipe command fails and the overall exit status is also non-zero.","categories":[{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/tags/shell/"},{"name":"zsh","slug":"zsh","permalink":"https://cyriltaylor.github.io/tags/zsh/"}]},{"title":"Kotlin编程详解","slug":"Kotlin/Kotlin编程详解","date":"2019-09-15T11:05:12.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/787202829/","link":"","permalink":"https://cyriltaylor.github.io/posts/787202829/","excerpt":"","text":"","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://cyriltaylor.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://cyriltaylor.github.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"C/C++编程技巧集锦","slug":"C++/C++编程技巧集锦","date":"2019-09-14T15:45:28.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/2902948804/","link":"","permalink":"https://cyriltaylor.github.io/posts/2902948804/","excerpt":"1. H1 2. H2","text":"1. H1 2. H2 1. H1 2. H2","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/tags/C-C/"},{"name":"编程技巧","slug":"编程技巧","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}]},{"title":"Linux驱动开发","slug":"Linux/Linux驱动开发","date":"2019-09-13T15:30:50.000Z","updated":"2020-08-27T18:02:44.000Z","comments":true,"path":"posts/3590725912/","link":"","permalink":"https://cyriltaylor.github.io/posts/3590725912/","excerpt":"1. 设备树 1.1. 设备树基础 1.2. 设备树语法 1.3. 设备树匹配解析规则 1.4. 支持设备树的驱动开发 1.5. Linux中常用的设备树API","text":"1. 设备树 1.1. 设备树基础 1.2. 设备树语法 1.3. 设备树匹配解析规则 1.4. 支持设备树的驱动开发 1.5. Linux中常用的设备树API 1. 设备树 1.1. 设备树基础 1.2. 设备树语法 12345678910111213141516171819202122232425262728/dts-v1/;#include &lt;dt-bindings/input/input.h&gt;#include &quot;armv7-m.dtsi&quot;/ &#123; model = compatible = chosen &#123; bootargs = &quot;console=ttySAC2,115200n8 root=/dev/nfs nfsroot=192.168.0.101:/home/run/work/rootfs/rootfs_3.16.57 ip=192.1 68.0.20 init=/linuxrci earlyprintk&quot;; &#125;; aliases &#123; &#125; node@0 &#123; an-empty-property; a-string-property = &quot;A string&quot;; a-string-list-property = &quot;first string&quot;, &quot;second string&quot;; a-byte-data-property = [0x01 0x23 0x45 0x67]; child-node@0 &#123; &#125; &#125;&#125; 1.3. 设备树匹配解析规则 1.4. 支持设备树的驱动开发 1.5. Linux中常用的设备树API 参考资料： [1] 设备树专题","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/tags/Linux/"},{"name":"Kernel","slug":"Kernel","permalink":"https://cyriltaylor.github.io/tags/Kernel/"}],"author":[{"name":null,"homepage":null,"photo":null}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/categories/shell/"},{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"https://cyriltaylor.github.io/categories/Java/"},{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/categories/C-C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://cyriltaylor.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://cyriltaylor.github.io/categories/Kotlin/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cyriltaylor.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://cyriltaylor.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"题库","slug":"题库","permalink":"https://cyriltaylor.github.io/tags/%E9%A2%98%E5%BA%93/"},{"name":"华为机试","slug":"华为机试","permalink":"https://cyriltaylor.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"},{"name":"技巧","slug":"技巧","permalink":"https://cyriltaylor.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"shell","slug":"shell","permalink":"https://cyriltaylor.github.io/tags/shell/"},{"name":"git","slug":"git","permalink":"https://cyriltaylor.github.io/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"https://cyriltaylor.github.io/tags/Linux/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://cyriltaylor.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"},{"name":"GPIO","slug":"GPIO","permalink":"https://cyriltaylor.github.io/tags/GPIO/"},{"name":"Pinctrl","slug":"Pinctrl","permalink":"https://cyriltaylor.github.io/tags/Pinctrl/"},{"name":"kernel API","slug":"kernel-API","permalink":"https://cyriltaylor.github.io/tags/kernel-API/"},{"name":"Java","slug":"Java","permalink":"https://cyriltaylor.github.io/tags/Java/"},{"name":"高级特性","slug":"高级特性","permalink":"https://cyriltaylor.github.io/tags/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"C/C++","slug":"C-C","permalink":"https://cyriltaylor.github.io/tags/C-C/"},{"name":"设备树","slug":"设备树","permalink":"https://cyriltaylor.github.io/tags/%E8%AE%BE%E5%A4%87%E6%A0%91/"},{"name":"编程规范","slug":"编程规范","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"name":"机器学习","slug":"机器学习","permalink":"https://cyriltaylor.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://cyriltaylor.github.io/tags/Python/"},{"name":"zsh","slug":"zsh","permalink":"https://cyriltaylor.github.io/tags/zsh/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://cyriltaylor.github.io/tags/Kotlin/"},{"name":"编程","slug":"编程","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"编程技巧","slug":"编程技巧","permalink":"https://cyriltaylor.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"},{"name":"Kernel","slug":"Kernel","permalink":"https://cyriltaylor.github.io/tags/Kernel/"}]}